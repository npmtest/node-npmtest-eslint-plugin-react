{"/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/test.js":"/* istanbul instrument in package npmtest_eslint_plugin_react */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/lib.npmtest_eslint_plugin_react.js":"/* istanbul instrument in package npmtest_eslint_plugin_react */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint_plugin_react = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint_plugin_react = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint-plugin-react && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint_plugin_react */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint_plugin_react\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint_plugin_react.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eslint_plugin_react.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint_plugin_react.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eslint_plugin_react.__dirname + '/lib.npmtest_eslint_plugin_react.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/index.js":"'use strict';\n\nvar has = require('has');\n\nvar allRules = {\n  'jsx-uses-react': require('./lib/rules/jsx-uses-react'),\n  'no-multi-comp': require('./lib/rules/no-multi-comp'),\n  'prop-types': require('./lib/rules/prop-types'),\n  'require-default-props': require('./lib/rules/require-default-props'),\n  'display-name': require('./lib/rules/display-name'),\n  'jsx-wrap-multilines': require('./lib/rules/jsx-wrap-multilines'),\n  'self-closing-comp': require('./lib/rules/self-closing-comp'),\n  'jsx-no-comment-textnodes': require('./lib/rules/jsx-no-comment-textnodes'),\n  'no-array-index-key': require('./lib/rules/no-array-index-key'),\n  'no-danger': require('./lib/rules/no-danger'),\n  'no-set-state': require('./lib/rules/no-set-state'),\n  'no-is-mounted': require('./lib/rules/no-is-mounted'),\n  'no-deprecated': require('./lib/rules/no-deprecated'),\n  'no-did-mount-set-state': require('./lib/rules/no-did-mount-set-state'),\n  'no-did-update-set-state': require('./lib/rules/no-did-update-set-state'),\n  'no-render-return-value': require('./lib/rules/no-render-return-value'),\n  'no-unescaped-entities': require('./lib/rules/no-unescaped-entities'),\n  'react-in-jsx-scope': require('./lib/rules/react-in-jsx-scope'),\n  'jsx-uses-vars': require('./lib/rules/jsx-uses-vars'),\n  'jsx-handler-names': require('./lib/rules/jsx-handler-names'),\n  'jsx-pascal-case': require('./lib/rules/jsx-pascal-case'),\n  'jsx-no-bind': require('./lib/rules/jsx-no-bind'),\n  'jsx-no-undef': require('./lib/rules/jsx-no-undef'),\n  'no-unknown-property': require('./lib/rules/no-unknown-property'),\n  'jsx-curly-spacing': require('./lib/rules/jsx-curly-spacing'),\n  'jsx-equals-spacing': require('./lib/rules/jsx-equals-spacing'),\n  'jsx-sort-props': require('./lib/rules/jsx-sort-props'),\n  'sort-prop-types': require('./lib/rules/sort-prop-types'),\n  'jsx-boolean-value': require('./lib/rules/jsx-boolean-value'),\n  'sort-comp': require('./lib/rules/sort-comp'),\n  'jsx-no-duplicate-props': require('./lib/rules/jsx-no-duplicate-props'),\n  'jsx-max-props-per-line': require('./lib/rules/jsx-max-props-per-line'),\n  'jsx-no-literals': require('./lib/rules/jsx-no-literals'),\n  'jsx-indent-props': require('./lib/rules/jsx-indent-props'),\n  'jsx-indent': require('./lib/rules/jsx-indent'),\n  'jsx-closing-bracket-location': require('./lib/rules/jsx-closing-bracket-location'),\n  'jsx-space-before-closing': require('./lib/rules/jsx-space-before-closing'),\n  'no-direct-mutation-state': require('./lib/rules/no-direct-mutation-state'),\n  'forbid-component-props': require('./lib/rules/forbid-component-props'),\n  'forbid-elements': require('./lib/rules/forbid-elements'),\n  'forbid-prop-types': require('./lib/rules/forbid-prop-types'),\n  'forbid-foreign-prop-types': require('./lib/rules/forbid-foreign-prop-types'),\n  'prefer-es6-class': require('./lib/rules/prefer-es6-class'),\n  'jsx-key': require('./lib/rules/jsx-key'),\n  'no-string-refs': require('./lib/rules/no-string-refs'),\n  'prefer-stateless-function': require('./lib/rules/prefer-stateless-function'),\n  'require-render-return': require('./lib/rules/require-render-return'),\n  'jsx-first-prop-new-line': require('./lib/rules/jsx-first-prop-new-line'),\n  'jsx-no-target-blank': require('./lib/rules/jsx-no-target-blank'),\n  'jsx-filename-extension': require('./lib/rules/jsx-filename-extension'),\n  'require-optimization': require('./lib/rules/require-optimization'),\n  'no-find-dom-node': require('./lib/rules/no-find-dom-node'),\n  'no-danger-with-children': require('./lib/rules/no-danger-with-children'),\n  'style-prop-object': require('./lib/rules/style-prop-object'),\n  'no-unused-prop-types': require('./lib/rules/no-unused-prop-types'),\n  'no-children-prop': require('./lib/rules/no-children-prop'),\n  'void-dom-elements-no-children': require('./lib/rules/void-dom-elements-no-children'),\n  'no-comment-textnodes': require('./lib/rules/no-comment-textnodes'),\n  'require-extension': require('./lib/rules/require-extension'),\n  'wrap-multilines': require('./lib/rules/wrap-multilines'),\n  'jsx-tag-spacing': require('./lib/rules/jsx-tag-spacing')\n};\n\nfunction filterRules(rules, predicate) {\n  var result = {};\n  for (var key in rules) {\n    if (has(rules, key) && predicate(rules[key])) {\n      result[key] = rules[key];\n    }\n  }\n  return result;\n}\n\nfunction configureAsError(rules) {\n  var result = {};\n  for (var key in rules) {\n    if (!has(rules, key)) {\n      continue;\n    }\n    result['react/' + key] = 2;\n  }\n  return result;\n}\n\nvar activeRules = filterRules(allRules, function(rule) {\n  return !rule.meta.deprecated;\n});\nvar activeRulesConfig = configureAsError(activeRules);\n\nvar deprecatedRules = filterRules(allRules, function(rule) {\n  return rule.meta.deprecated;\n});\n\nmodule.exports = {\n  deprecatedRules: deprecatedRules,\n  rules: allRules,\n  configs: {\n    recommended: {\n      plugins: [\n        'react'\n      ],\n      parserOptions: {\n        ecmaFeatures: {\n          jsx: true\n        }\n      },\n      rules: {\n        'react/display-name': 2,\n        'react/jsx-no-duplicate-props': 2,\n        'react/jsx-no-undef': 2,\n        'react/jsx-uses-react': 2,\n        'react/jsx-uses-vars': 2,\n        'react/no-deprecated': 2,\n        'react/no-direct-mutation-state': 2,\n        'react/no-find-dom-node': 2,\n        'react/no-is-mounted': 2,\n        'react/no-unknown-property': 2,\n        'react/no-render-return-value': 2,\n        'react/prop-types': 2,\n        'react/react-in-jsx-scope': 2,\n        'react/require-render-return': 2\n      }\n    },\n    all: {\n      plugins: [\n        'react'\n      ],\n      parserOptions: {\n        ecmaFeatures: {\n          jsx: true\n        }\n      },\n      rules: activeRulesConfig\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js":"/**\n * @fileoverview Prevent React to be marked as unused\n * @author Glen Mailer\n */\n'use strict';\n\nvar pragmaUtil = require('../util/pragma');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent React to be marked as unused',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    var pragma = pragmaUtil.getFromContext(context);\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      JSXOpeningElement: function() {\n        context.markVariableAsUsed(pragma);\n      },\n\n      BlockComment: function(node) {\n        pragma = pragmaUtil.getFromNode(node) || pragma;\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/pragma.js":"/**\n * @fileoverview Utility functions for React pragma configuration\n * @author Yannick Croissant\n */\n'use strict';\n\nvar JSX_ANNOTATION_REGEX = /^\\*\\s*@jsx\\s+([^\\s]+)/;\n// Does not check for reserved keywords or unicode characters\nvar JS_IDENTIFIER_REGEX = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;\n\n\nfunction getCreateClassFromContext(context) {\n  var pragma = 'createClass';\n  // .eslintrc shared settings (http://eslint.org/docs/user-guide/configuring#adding-shared-settings)\n  if (context.settings.react && context.settings.react.createClass) {\n    pragma = context.settings.react.createClass;\n  }\n  if (!JS_IDENTIFIER_REGEX.test(pragma)) {\n    throw new Error('createClass pragma ' + pragma + 'is not a valid function name');\n  }\n  return pragma;\n}\n\nfunction getFromContext(context) {\n  var pragma = 'React';\n  // .eslintrc shared settings (http://eslint.org/docs/user-guide/configuring#adding-shared-settings)\n  if (context.settings.react && context.settings.react.pragma) {\n    pragma = context.settings.react.pragma;\n  }\n  if (!JS_IDENTIFIER_REGEX.test(pragma)) {\n    throw new Error('React pragma ' + pragma + 'is not a valid identifier');\n  }\n  return pragma;\n}\n\nfunction getFromNode(node) {\n  var matches = JSX_ANNOTATION_REGEX.exec(node.value);\n  if (!matches) {\n    return false;\n  }\n  return matches[1].split('.')[0];\n}\n\nmodule.exports = {\n  getCreateClassFromContext: getCreateClassFromContext,\n  getFromContext: getFromContext,\n  getFromNode: getFromNode\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js":"/**\n * @fileoverview Prevent multiple component definition per file\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent multiple component definition per file',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreStateless: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components) {\n\n    var configuration = context.options[0] || {};\n    var ignoreStateless = configuration.ignoreStateless || false;\n\n    var MULTI_COMP_MESSAGE = 'Declare only one React component per file';\n\n    /**\n     * Checks if the component is ignored\n     * @param {Object} component The component being checked.\n     * @returns {Boolean} True if the component is ignored, false if not.\n     */\n    function isIgnored(component) {\n      return ignoreStateless && /Function/.test(component.node.type);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'Program:exit': function() {\n        if (components.length() <= 1) {\n          return;\n        }\n\n        var list = components.list();\n        var i = 0;\n\n        for (var component in list) {\n          if (!has(list, component) || isIgnored(list[component]) || ++i === 1) {\n            continue;\n          }\n          context.report({\n            node: list[component].node,\n            message: MULTI_COMP_MESSAGE\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/Components.js":"/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\nvar util = require('util');\nvar doctrine = require('doctrine');\nvar variableUtil = require('./variable');\nvar pragmaUtil = require('./pragma');\n\n/**\n * Components\n * @class\n */\nfunction Components() {\n  this._list = {};\n  this._getId = function(node) {\n    return node && node.range.join(':');\n  };\n}\n\n/**\n * Add a node to the components list, or update it if it's already in the list\n *\n * @param {ASTNode} node The AST node being added.\n * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n * @returns {Object} Added component object\n */\nComponents.prototype.add = function(node, confidence) {\n  var id = this._getId(node);\n  if (this._list[id]) {\n    if (confidence === 0 || this._list[id].confidence === 0) {\n      this._list[id].confidence = 0;\n    } else {\n      this._list[id].confidence = Math.max(this._list[id].confidence, confidence);\n    }\n    return this._list[id];\n  }\n  this._list[id] = {\n    node: node,\n    confidence: confidence\n  };\n  return this._list[id];\n};\n\n/**\n * Find a component in the list using its node\n *\n * @param {ASTNode} node The AST node being searched.\n * @returns {Object} Component object, undefined if the component is not found\n */\nComponents.prototype.get = function(node) {\n  var id = this._getId(node);\n  return this._list[id];\n};\n\n/**\n * Update a component in the list\n *\n * @param {ASTNode} node The AST node being updated.\n * @param {Object} props Additional properties to add to the component.\n */\nComponents.prototype.set = function(node, props) {\n  while (node && !this._list[this._getId(node)]) {\n    node = node.parent;\n  }\n  if (!node) {\n    return;\n  }\n  var id = this._getId(node);\n  this._list[id] = util._extend(this._list[id], props);\n};\n\n/**\n * Return the components list\n * Components for which we are not confident are not returned\n *\n * @returns {Object} Components list\n */\nComponents.prototype.list = function() {\n  var list = {};\n  var usedPropTypes = {};\n  // Find props used in components for which we are not confident\n  for (var i in this._list) {\n    if (!has(this._list, i) || this._list[i].confidence >= 2) {\n      continue;\n    }\n    var component = null;\n    var node = null;\n    node = this._list[i].node;\n    while (!component && node.parent) {\n      node = node.parent;\n      // Stop moving up if we reach a decorator\n      if (node.type === 'Decorator') {\n        break;\n      }\n      component = this.get(node);\n    }\n    if (component) {\n      usedPropTypes[this._getId(component.node)] = (this._list[i].usedPropTypes || []).filter(function(propType) {\n        return !propType.node || propType.node.kind !== 'init';\n      });\n    }\n  }\n  // Assign used props in not confident components to the parent component\n  for (var j in this._list) {\n    if (!has(this._list, j) || this._list[j].confidence < 2) {\n      continue;\n    }\n    var id = this._getId(this._list[j].node);\n    list[j] = this._list[j];\n    if (usedPropTypes[id]) {\n      list[j].usedPropTypes = (list[j].usedPropTypes || []).concat(usedPropTypes[id]);\n    }\n  }\n  return list;\n};\n\n/**\n * Return the length of the components list\n * Components for which we are not confident are not counted\n *\n * @returns {Number} Components list length\n */\nComponents.prototype.length = function() {\n  var length = 0;\n  for (var i in this._list) {\n    if (!has(this._list, i) || this._list[i].confidence < 2) {\n      continue;\n    }\n    length++;\n  }\n  return length;\n};\n\nfunction componentRule(rule, context) {\n\n  var createClass = pragmaUtil.getCreateClassFromContext(context);\n  var pragma = pragmaUtil.getFromContext(context);\n  var sourceCode = context.getSourceCode();\n  var components = new Components();\n\n  // Utilities for component detection\n  var utils = {\n\n    /**\n     * Check if the node is a React ES5 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES5 component, false if not\n     */\n    isES5Component: function(node) {\n      if (!node.parent) {\n        return false;\n      }\n      return new RegExp('^(' + pragma + '\\\\.)?' + createClass + '$').test(sourceCode.getText(node.parent.callee));\n    },\n\n    /**\n     * Check if the node is a React ES6 component\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a React ES6 component, false if not\n     */\n    isES6Component: function(node) {\n      if (utils.isExplicitComponent(node)) {\n        return true;\n      }\n\n      if (!node.superClass) {\n        return false;\n      }\n      return new RegExp('^(' + pragma + '\\\\.)?(Pure)?Component$').test(sourceCode.getText(node.superClass));\n    },\n\n    /**\n     * Check if the node is explicitly declared as a descendant of a React Component\n     *\n     * @param {ASTNode} node The AST node being checked (can be a ReturnStatement or an ArrowFunctionExpression).\n     * @returns {Boolean} True if the node is explicitly declared as a descendant of a React Component, false if not\n     */\n    isExplicitComponent: function(node) {\n      var comment = sourceCode.getJSDocComment(node);\n\n      if (comment === null) {\n        return false;\n      }\n\n      var commentAst = doctrine.parse(comment.value, {\n        unwrap: true,\n        tags: ['extends', 'augments']\n      });\n\n      var relevantTags = commentAst.tags.filter(function(tag) {\n        return tag.name === 'React.Component' || tag.name === 'React.PureComponent';\n      });\n\n      return relevantTags.length > 0;\n    },\n\n    /**\n     * Checks to see if our component extends React.PureComponent\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node extends React.PureComponent, false if not\n     */\n    isPureComponent: function (node) {\n      if (node.superClass) {\n        return new RegExp('^(' + pragma + '\\\\.)?PureComponent$').test(sourceCode.getText(node.superClass));\n      }\n      return false;\n    },\n\n    /**\n     * Check if createElement is destructured from React import\n     *\n     * @returns {Boolean} True if createElement is destructured from React\n     */\n    hasDestructuredReactCreateElement: function() {\n      var variables = variableUtil.variablesInScope(context);\n      var variable = variableUtil.getVariable(variables, 'createElement');\n      if (variable) {\n        var map = variable.scope.set;\n        if (map.has('React')) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Checks to see if node is called within React.createElement\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if React.createElement called\n     */\n    isReactCreateElement: function(node) {\n      var calledOnReact = (\n        node &&\n        node.callee &&\n        node.callee.object &&\n        node.callee.object.name === 'React' &&\n        node.callee.property &&\n        node.callee.property.name === 'createElement'\n      );\n\n      var calledDirectly = (\n        node &&\n        node.callee &&\n        node.callee.name === 'createElement'\n      );\n\n      if (this.hasDestructuredReactCreateElement()) {\n        return calledDirectly || calledOnReact;\n      }\n      return calledOnReact;\n    },\n\n    /**\n     * Check if the node is returning JSX\n     *\n     * @param {ASTNode} ASTnode The AST node being checked\n     * @param {Boolean} strict If true, in a ternary condition the node must return JSX in both cases\n     * @returns {Boolean} True if the node is returning JSX, false if not\n     */\n    isReturningJSX: function(ASTnode, strict) {\n      var property;\n      var node = ASTnode;\n      switch (node.type) {\n        case 'ReturnStatement':\n          property = 'argument';\n          break;\n        case 'ArrowFunctionExpression':\n          property = 'body';\n          break;\n        default:\n          node = utils.findReturnStatement(node);\n          if (!node) {\n            return false;\n          }\n          property = 'argument';\n      }\n\n      var returnsConditionalJSXConsequent =\n        node[property] &&\n        node[property].type === 'ConditionalExpression' &&\n        node[property].consequent.type === 'JSXElement'\n      ;\n      var returnsConditionalJSXAlternate =\n        node[property] &&\n        node[property].type === 'ConditionalExpression' &&\n        node[property].alternate.type === 'JSXElement'\n      ;\n      var returnsConditionalJSX =\n        strict ? (returnsConditionalJSXConsequent && returnsConditionalJSXAlternate) :\n        (returnsConditionalJSXConsequent || returnsConditionalJSXAlternate);\n\n      var returnsJSX =\n        node[property] &&\n        node[property].type === 'JSXElement'\n      ;\n      var returnsReactCreateElement = this.isReactCreateElement(node[property]);\n\n      return Boolean(\n        returnsConditionalJSX ||\n        returnsJSX ||\n        returnsReactCreateElement\n      );\n    },\n\n    /**\n     * Find a return statment in the current node\n     *\n     * @param {ASTNode} ASTnode The AST node being checked\n     */\n    findReturnStatement: function(node) {\n      if (!node.value || !node.value.body || !node.value.body.body) {\n        return false;\n      }\n      var i = node.value.body.body.length - 1;\n      for (; i >= 0; i--) {\n        if (node.value.body.body[i].type === 'ReturnStatement') {\n          return node.value.body.body[i];\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Get the parent component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent: function() {\n      return (\n        utils.getParentES6Component() ||\n        utils.getParentES5Component() ||\n        utils.getParentStatelessComponent()\n      );\n    },\n\n    /**\n     * Get the parent ES5 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES5Component: function() {\n      var scope = context.getScope();\n      while (scope) {\n        var node = scope.block && scope.block.parent && scope.block.parent.parent;\n        if (node && utils.isES5Component(node)) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the parent ES6 component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentES6Component: function() {\n      var scope = context.getScope();\n      while (scope && scope.type !== 'class') {\n        scope = scope.upper;\n      }\n      var node = scope && scope.block;\n      if (!node || !utils.isES6Component(node)) {\n        return null;\n      }\n      return node;\n    },\n\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent: function() {\n      var scope = context.getScope();\n      while (scope) {\n        var node = scope.block;\n        var isClass = node.type === 'ClassExpression';\n        var isFunction = /Function/.test(node.type); // Functions\n        var isMethod = node.parent && node.parent.type === 'MethodDefinition'; // Classes methods\n        var isArgument = node.parent && node.parent.type === 'CallExpression'; // Arguments (callback, etc.)\n        // Attribute Expressions inside JSX Elements (<button onClick={() => props.handleClick()}></button>)\n        var isJSXExpressionContainer = node.parent && node.parent.type === 'JSXExpressionContainer';\n        // Stop moving up if we reach a class or an argument (like a callback)\n        if (isClass || isArgument) {\n          return null;\n        }\n        // Return the node if it is a function that is not a class method and is not inside a JSX Element\n        if (isFunction && !isMethod && !isJSXExpressionContainer) {\n          return node;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode} component node, null if we cannot find the component\n     */\n    getRelatedComponent: function(node) {\n      var i;\n      var j;\n      var k;\n      var l;\n      var componentName;\n      var componentNode;\n      // Get the component path\n      var componentPath = [];\n      while (node) {\n        if (node.property && node.property.type === 'Identifier') {\n          componentPath.push(node.property.name);\n        }\n        if (node.object && node.object.type === 'Identifier') {\n          componentPath.push(node.object.name);\n        }\n        node = node.object;\n      }\n      componentPath.reverse();\n      componentName = componentPath.slice(0, componentPath.length - 1).join('.');\n\n      // Find the variable in the current scope\n      var variableName = componentPath.shift();\n      if (!variableName) {\n        return null;\n      }\n      var variableInScope;\n      var variables = variableUtil.variablesInScope(context);\n      for (i = 0, j = variables.length; i < j; i++) {\n        if (variables[i].name === variableName) {\n          variableInScope = variables[i];\n          break;\n        }\n      }\n      if (!variableInScope) {\n        return null;\n      }\n\n      // Try to find the component using variable references\n      var refs = variableInScope.references;\n      var refId;\n      for (i = 0, j = refs.length; i < j; i++) {\n        refId = refs[i].identifier;\n        if (refId.parent && refId.parent.type === 'MemberExpression') {\n          refId = refId.parent;\n        }\n        if (sourceCode.getText(refId) !== componentName) {\n          continue;\n        }\n        if (refId.type === 'MemberExpression') {\n          componentNode = refId.parent.right;\n        } else if (refId.parent && refId.parent.type === 'VariableDeclarator') {\n          componentNode = refId.parent.init;\n        }\n        break;\n      }\n\n      if (componentNode) {\n        // Return the component\n        return components.add(componentNode, 1);\n      }\n\n      // Try to find the component using variable declarations\n      var defInScope;\n      var defs = variableInScope.defs;\n      for (i = 0, j = defs.length; i < j; i++) {\n        if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {\n          defInScope = defs[i];\n          break;\n        }\n      }\n      if (!defInScope || !defInScope.node) {\n        return null;\n      }\n      componentNode = defInScope.node.init || defInScope.node;\n\n      // Traverse the node properties to the component declaration\n      for (i = 0, j = componentPath.length; i < j; i++) {\n        if (!componentNode.properties) {\n          continue;\n        }\n        for (k = 0, l = componentNode.properties.length; k < l; k++) {\n          if (componentNode.properties[k].key.name === componentPath[i]) {\n            componentNode = componentNode.properties[k];\n            break;\n          }\n        }\n        if (!componentNode || !componentNode.value) {\n          return null;\n        }\n        componentNode = componentNode.value;\n      }\n\n      // Return the component\n      return components.add(componentNode, 1);\n    }\n  };\n\n  // Component detection instructions\n  var detectionInstructions = {\n    ClassExpression: function(node) {\n      if (!utils.isES6Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ClassDeclaration: function(node) {\n      if (!utils.isES6Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ClassProperty: function(node) {\n      node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ObjectExpression: function(node) {\n      if (!utils.isES5Component(node)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    FunctionExpression: function(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n      var component = utils.getParentComponent();\n      if (\n        !component ||\n        (component.parent && component.parent.type === 'JSXExpressionContainer')\n      ) {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n      components.add(component, 1);\n    },\n\n    FunctionDeclaration: function(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n      node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 1);\n    },\n\n    ArrowFunctionExpression: function(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n      var component = utils.getParentComponent();\n      if (\n        !component ||\n        (component.parent && component.parent.type === 'JSXExpressionContainer')\n      ) {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n      if (component.expression && utils.isReturningJSX(component)) {\n        components.add(component, 2);\n      } else {\n        components.add(component, 1);\n      }\n    },\n\n    ThisExpression: function(node) {\n      var component = utils.getParentComponent();\n      if (!component || !/Function/.test(component.type) || !node.parent.property) {\n        return;\n      }\n      // Ban functions accessing a property on a ThisExpression\n      components.add(node, 0);\n    },\n\n    BlockComment: function(node) {\n      pragma = pragmaUtil.getFromNode(node) || pragma;\n    },\n\n    ReturnStatement: function(node) {\n      if (!utils.isReturningJSX(node)) {\n        return;\n      }\n      node = utils.getParentComponent();\n      if (!node) {\n        var scope = context.getScope();\n        components.add(scope.block, 1);\n        return;\n      }\n      components.add(node, 2);\n    }\n  };\n\n  // Update the provided rule instructions to add the component detection\n  var ruleInstructions = rule(context, components, utils);\n  var updatedRuleInstructions = util._extend({}, ruleInstructions);\n  Object.keys(detectionInstructions).forEach(function(instruction) {\n    updatedRuleInstructions[instruction] = function(node) {\n      detectionInstructions[instruction](node);\n      return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : void 0;\n    };\n  });\n  // Return the updated rule instructions\n  return updatedRuleInstructions;\n}\n\nComponents.detect = function(rule) {\n  return componentRule.bind(this, rule);\n};\n\nmodule.exports = Components;\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/variable.js":"/**\n * @fileoverview Utility functions for React components detection\n * @author Yannick Croissant\n */\n'use strict';\n\nvar find = require('array.prototype.find');\n\n/**\n * Search a particular variable in a list\n * @param {Array} variables The variables list.\n * @param {Array} name The name of the variable to search.\n * @returns {Boolean} True if the variable was found, false if not.\n */\nfunction findVariable(variables, name) {\n  return variables.some(function (variable) {\n    return variable.name === name;\n  });\n}\n\n/**\n * Find and return a particular variable in a list\n * @param {Array} variables The variables list.\n * @param {Array} name The name of the variable to search.\n * @returns {Object} Variable if the variable was found, null if not.\n */\nfunction getVariable(variables, name) {\n  return find(variables, function (variable) {\n    return variable.name === name;\n  });\n}\n\n/**\n * List all variable in a given scope\n *\n * Contain a patch for babel-eslint to avoid https://github.com/babel/babel-eslint/issues/21\n *\n * @param {Object} context The current rule context.\n * @returns {Array} The variables list\n */\nfunction variablesInScope(context) {\n  var scope = context.getScope();\n  var variables = scope.variables;\n\n  while (scope.type !== 'global') {\n    scope = scope.upper;\n    variables = scope.variables.concat(variables);\n  }\n  if (scope.childScopes.length) {\n    variables = scope.childScopes[0].variables.concat(variables);\n    if (scope.childScopes[0].childScopes.length) {\n      variables = scope.childScopes[0].childScopes[0].variables.concat(variables);\n    }\n  }\n  variables.reverse();\n\n  return variables;\n}\n\nmodule.exports = {\n  findVariable: findVariable,\n  getVariable: getVariable,\n  variablesInScope: variablesInScope\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/prop-types.js":"/**\n * @fileoverview Prevent missing props validation in a React component definition\n * @author Yannick Croissant\n */\n'use strict';\n\n// As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/yannickcr/eslint-plugin-react/issues/7\n\nvar has = require('has');\nvar Components = require('../util/Components');\nvar variable = require('../util/variable');\nvar annotations = require('../util/annotations');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar PROPS_REGEX = /^(props|nextProps)$/;\nvar DIRECT_PROPS_REGEX = /^(props|nextProps)\\s*(\\.|\\[)/;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent missing props validation in a React component definition',\n      category: 'Best Practices',\n      recommended: true\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        skipUndeclared: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    var sourceCode = context.getSourceCode();\n    var configuration = context.options[0] || {};\n    var ignored = configuration.ignore || [];\n    var customValidators = configuration.customValidators || [];\n    var skipUndeclared = configuration.skipUndeclared || false;\n    // Used to track the type annotations in scope.\n    // Necessary because babel's scopes do not track type annotations.\n    var stack = null;\n\n    var MISSING_MESSAGE = '\\'{{name}}\\' is missing in props validation';\n\n    /**\n     * Helper for accessing the current scope in the stack.\n     * @param {string} key The name of the identifier to access. If omitted, returns the full scope.\n     * @param {ASTNode} value If provided sets the new value for the identifier.\n     * @returns {Object|ASTNode} Either the whole scope or the ASTNode associated with the given identifier.\n     */\n    function typeScope(key, value) {\n      if (arguments.length === 0) {\n        return stack[stack.length - 1];\n      } else if (arguments.length === 1) {\n        return stack[stack.length - 1][key];\n      }\n      stack[stack.length - 1][key] = value;\n      return value;\n    }\n\n    /**\n     * Check if we are in a class constructor\n     * @return {boolean} true if we are in a class constructor, false if not\n     */\n    function inConstructor() {\n      var scope = context.getScope();\n      while (scope) {\n        if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n          return true;\n        }\n        scope = scope.upper;\n      }\n      return false;\n    }\n\n    /**\n     * Check if we are in a class constructor\n     * @return {boolean} true if we are in a class constructor, false if not\n     */\n    function inComponentWillReceiveProps() {\n      var scope = context.getScope();\n      while (scope) {\n        if (\n          scope.block && scope.block.parent &&\n          scope.block.parent.key && scope.block.parent.key.name === 'componentWillReceiveProps'\n        ) {\n          return true;\n        }\n        scope = scope.upper;\n      }\n      return false;\n    }\n\n    /**\n     * Checks if we are using a prop\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are using a prop, false if not.\n     */\n    function isPropTypesUsage(node) {\n      var isClassUsage = (\n        (utils.getParentES6Component() || utils.getParentES5Component()) &&\n        node.object.type === 'ThisExpression' && node.property.name === 'props'\n      );\n      var isStatelessFunctionUsage = node.object.name === 'props';\n      var isNextPropsUsage = node.object.name === 'nextProps' && inComponentWillReceiveProps();\n      return isClassUsage || isStatelessFunctionUsage || isNextPropsUsage;\n    }\n\n    /**\n     * Checks if we are declaring a `props` class property with a flow type annotation.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a type annotated props declaration, false if not.\n     */\n    function isAnnotatedClassPropsDeclaration(node) {\n      if (node && node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        if (\n          node.typeAnnotation && (\n            tokens[0].value === 'props' ||\n            (tokens[1] && tokens[1].value === 'props')\n          )\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Checks if we are declaring a prop\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a prop, false if not.\n     */\n    function isPropTypesDeclaration(node) {\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node && node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        if (\n          tokens[0].value === 'propTypes' ||\n          (tokens[1] && tokens[1].value === 'propTypes')\n        ) {\n          return true;\n        }\n        return false;\n      }\n\n      return Boolean(\n        node &&\n        node.name === 'propTypes'\n      );\n\n    }\n\n    /**\n     * Checks if the prop is ignored\n     * @param {String} name Name of the prop to check.\n     * @returns {Boolean} True if the prop is ignored, false if not.\n     */\n    function isIgnored(name) {\n      return ignored.indexOf(name) !== -1;\n    }\n\n    /**\n     * Checks if prop should be validated by plugin-react-proptypes\n     * @param {String} validator Name of validator to check.\n     * @returns {Boolean} True if validator should be checked by custom validator.\n     */\n    function hasCustomValidator(validator) {\n      return customValidators.indexOf(validator) !== -1;\n    }\n\n    /**\n     * Checks if the component must be validated\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component must be validated, false if not.\n     */\n    function mustBeValidated(component) {\n      var isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';\n      return Boolean(\n        component &&\n        component.usedPropTypes &&\n        !component.ignorePropsValidation &&\n        !isSkippedByConfig\n      );\n    }\n\n    /**\n     * Internal: Checks if the prop is declared\n     * @param {Object} declaredPropTypes Description of propTypes declared in the current component\n     * @param {String[]} keyList Dot separated name of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n    function _isDeclaredInComponent(declaredPropTypes, keyList) {\n      for (var i = 0, j = keyList.length; i < j; i++) {\n        var key = keyList[i];\n        var propType = (\n          declaredPropTypes && (\n            // Check if this key is declared\n            (declaredPropTypes[key] || // If not, check if this type accepts any key\n            declaredPropTypes.__ANY_KEY__)\n          )\n        );\n\n        if (!propType) {\n          // If it's a computed property, we can't make any further analysis, but is valid\n          return key === '__COMPUTED_PROP__';\n        }\n        if (propType === true) {\n          return true;\n        }\n        // Consider every children as declared\n        if (propType.children === true) {\n          return true;\n        }\n        if (propType.acceptedProperties) {\n          return key in propType.acceptedProperties;\n        }\n        if (propType.type === 'union') {\n          // If we fall in this case, we know there is at least one complex type in the union\n          if (i + 1 >= j) {\n            // this is the last key, accept everything\n            return true;\n          }\n          // non trivial, check all of them\n          var unionTypes = propType.children;\n          var unionPropType = {};\n          for (var k = 0, z = unionTypes.length; k < z; k++) {\n            unionPropType[key] = unionTypes[k];\n            var isValid = _isDeclaredInComponent(\n              unionPropType,\n              keyList.slice(i)\n            );\n            if (isValid) {\n              return true;\n            }\n          }\n\n          // every possible union were invalid\n          return false;\n        }\n        declaredPropTypes = propType.children;\n      }\n      return true;\n    }\n\n    /**\n     * Checks if the prop is declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {String[]} names List of names of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n    function isDeclaredInComponent(node, names) {\n      while (node) {\n        var component = components.get(node);\n        var isDeclared =\n          component && component.confidence === 2 &&\n          _isDeclaredInComponent(component.declaredPropTypes || {}, names)\n        ;\n        if (isDeclared) {\n          return true;\n        }\n        node = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Checks if the prop has spread operator.\n     * @param {ASTNode} node The AST node being marked.\n     * @returns {Boolean} True if the prop has spread operator, false if not.\n     */\n    function hasSpreadOperator(node) {\n      var tokens = sourceCode.getTokens(node);\n      return tokens.length && tokens[0].value === '...';\n    }\n\n    /**\n     * Retrieve the name of a key node\n     * @param {ASTNode} node The AST node with the key.\n     * @return {string} the name of the key\n     */\n    function getKeyValue(node) {\n      if (node.type === 'ObjectTypeProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return (tokens[0].value === '+' || tokens[0].value === '-'\n          ? tokens[1].value\n          : tokens[0].value\n        );\n      }\n      var key = node.key || node.argument;\n      return key.type === 'Identifier' ? key.name : key.value;\n    }\n\n    /**\n     * Iterates through a properties node, like a customized forEach.\n     * @param {Object[]} properties Array of properties to iterate.\n     * @param {Function} fn Function to call on each property, receives property key\n        and property value. (key, value) => void\n     */\n    function iterateProperties(properties, fn) {\n      if (properties.length && typeof fn === 'function') {\n        for (var i = 0, j = properties.length; i < j; i++) {\n          var node = properties[i];\n          var key = getKeyValue(node);\n\n          var value = node.value;\n          fn(key, value);\n        }\n      }\n    }\n\n    /**\n     * Creates the representation of the React propTypes for the component.\n     * The representation is used to verify nested used properties.\n     * @param {ASTNode} value Node of the React.PropTypes for the desired property\n     * @return {Object|Boolean} The representation of the declaration, true means\n     *    the property is declared without the need for further analysis.\n     */\n    function buildReactDeclarationTypes(value) {\n      if (\n        value &&\n        value.callee &&\n        value.callee.object &&\n        hasCustomValidator(value.callee.object.name)\n      ) {\n        return true;\n      }\n\n      if (\n        value &&\n        value.type === 'MemberExpression' &&\n        value.property &&\n        value.property.name &&\n        value.property.name === 'isRequired'\n      ) {\n        value = value.object;\n      }\n\n      // Verify React.PropTypes that are functions\n      if (\n        value &&\n        value.type === 'CallExpression' &&\n        value.callee &&\n        value.callee.property &&\n        value.callee.property.name &&\n        value.arguments &&\n        value.arguments.length > 0\n      ) {\n        var callName = value.callee.property.name;\n        var argument = value.arguments[0];\n        switch (callName) {\n          case 'shape':\n            if (argument.type !== 'ObjectExpression') {\n              // Invalid proptype or cannot analyse statically\n              return true;\n            }\n            var shapeTypeDefinition = {\n              type: 'shape',\n              children: {}\n            };\n            iterateProperties(argument.properties, function(childKey, childValue) {\n              shapeTypeDefinition.children[childKey] = buildReactDeclarationTypes(childValue);\n            });\n            return shapeTypeDefinition;\n          case 'arrayOf':\n          case 'objectOf':\n            return {\n              type: 'object',\n              children: {\n                __ANY_KEY__: buildReactDeclarationTypes(argument)\n              }\n            };\n          case 'oneOfType':\n            if (\n              !argument.elements ||\n              !argument.elements.length\n            ) {\n              // Invalid proptype or cannot analyse statically\n              return true;\n            }\n            var unionTypeDefinition = {\n              type: 'union',\n              children: []\n            };\n            for (var i = 0, j = argument.elements.length; i < j; i++) {\n              var type = buildReactDeclarationTypes(argument.elements[i]);\n              // keep only complex type\n              if (type !== true) {\n                if (type.children === true) {\n                  // every child is accepted for one type, abort type analysis\n                  unionTypeDefinition.children = true;\n                  return unionTypeDefinition;\n                }\n              }\n\n              unionTypeDefinition.children.push(type);\n            }\n            if (unionTypeDefinition.length === 0) {\n              // no complex type found, simply accept everything\n              return true;\n            }\n            return unionTypeDefinition;\n          case 'instanceOf':\n            return {\n              type: 'instance',\n              // Accept all children because we can't know what type they are\n              children: true\n            };\n          case 'oneOf':\n          default:\n            return true;\n        }\n      }\n      // Unknown property or accepts everything (any, object, ...)\n      return true;\n    }\n\n    /**\n     * Creates the representation of the React props type annotation for the component.\n     * The representation is used to verify nested used properties.\n     * @param {ASTNode} annotation Type annotation for the props class property.\n     * @return {Object|Boolean} The representation of the declaration, true means\n     *    the property is declared without the need for further analysis.\n     */\n    function buildTypeAnnotationDeclarationTypes(annotation) {\n      switch (annotation.type) {\n        case 'GenericTypeAnnotation':\n          if (typeScope(annotation.id.name)) {\n            return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name));\n          }\n          return true;\n        case 'ObjectTypeAnnotation':\n          var shapeTypeDefinition = {\n            type: 'shape',\n            children: {}\n          };\n          iterateProperties(annotation.properties, function(childKey, childValue) {\n            shapeTypeDefinition.children[childKey] = buildTypeAnnotationDeclarationTypes(childValue);\n          });\n          return shapeTypeDefinition;\n        case 'UnionTypeAnnotation':\n          var unionTypeDefinition = {\n            type: 'union',\n            children: []\n          };\n          for (var i = 0, j = annotation.types.length; i < j; i++) {\n            var type = buildTypeAnnotationDeclarationTypes(annotation.types[i]);\n            // keep only complex type\n            if (type !== true) {\n              if (type.children === true) {\n                // every child is accepted for one type, abort type analysis\n                unionTypeDefinition.children = true;\n                return unionTypeDefinition;\n              }\n            }\n\n            unionTypeDefinition.children.push(type);\n          }\n          if (unionTypeDefinition.children.length === 0) {\n            // no complex type found, simply accept everything\n            return true;\n          }\n          return unionTypeDefinition;\n        case 'ArrayTypeAnnotation':\n          return {\n            type: 'object',\n            children: {\n              __ANY_KEY__: buildTypeAnnotationDeclarationTypes(annotation.elementType)\n            }\n          };\n        default:\n          // Unknown or accepts everything.\n          return true;\n      }\n    }\n\n    /**\n     * Retrieve the name of a property node\n     * @param {ASTNode} node The AST node with the property.\n     * @return {string} the name of the property or undefined if not found\n     */\n    function getPropertyName(node) {\n      var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));\n      var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();\n      var isNotInConstructor = !inConstructor();\n      var isNotInComponentWillReceiveProps = !inComponentWillReceiveProps();\n      if (isDirectProp && isInClassComponent && isNotInConstructor && isNotInComponentWillReceiveProps) {\n        return void 0;\n      }\n      if (!isDirectProp) {\n        node = node.parent;\n      }\n      var property = node.property;\n      if (property) {\n        switch (property.type) {\n          case 'Identifier':\n            if (node.computed) {\n              return '__COMPUTED_PROP__';\n            }\n            return property.name;\n          case 'MemberExpression':\n            return void 0;\n          case 'Literal':\n            // Accept computed properties that are literal strings\n            if (typeof property.value === 'string') {\n              return property.value;\n            }\n            // falls through\n          default:\n            if (node.computed) {\n              return '__COMPUTED_PROP__';\n            }\n            break;\n        }\n      }\n      return void 0;\n    }\n\n    /**\n     * Mark a prop type as used\n     * @param {ASTNode} node The AST node being marked.\n     */\n    function markPropTypesAsUsed(node, parentNames) {\n      parentNames = parentNames || [];\n      var type;\n      var name;\n      var allNames;\n      var properties;\n      switch (node.type) {\n        case 'MemberExpression':\n          name = getPropertyName(node);\n          if (name) {\n            allNames = parentNames.concat(name);\n            if (node.parent.type === 'MemberExpression') {\n              markPropTypesAsUsed(node.parent, allNames);\n            }\n            // Do not mark computed props as used.\n            type = name !== '__COMPUTED_PROP__' ? 'direct' : null;\n          } else if (\n            node.parent.id &&\n            node.parent.id.properties &&\n            node.parent.id.properties.length &&\n            getKeyValue(node.parent.id.properties[0])\n          ) {\n            type = 'destructuring';\n            properties = node.parent.id.properties;\n          }\n          break;\n        case 'ArrowFunctionExpression':\n        case 'FunctionDeclaration':\n        case 'FunctionExpression':\n          type = 'destructuring';\n          properties = node.params[0].properties;\n          break;\n        case 'VariableDeclarator':\n          for (var i = 0, j = node.id.properties.length; i < j; i++) {\n            // let {props: {firstname}} = this\n            var thisDestructuring = (\n              !hasSpreadOperator(node.id.properties[i]) &&\n              (PROPS_REGEX.test(node.id.properties[i].key.name) || PROPS_REGEX.test(node.id.properties[i].key.value)) &&\n              node.id.properties[i].value.type === 'ObjectPattern'\n            );\n            // let {firstname} = props\n            var directDestructuring =\n              PROPS_REGEX.test(node.init.name) &&\n              (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps())\n            ;\n\n            if (thisDestructuring) {\n              properties = node.id.properties[i].value.properties;\n            } else if (directDestructuring) {\n              properties = node.id.properties;\n            } else {\n              continue;\n            }\n            type = 'destructuring';\n            break;\n          }\n          break;\n        default:\n          throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');\n      }\n\n      var component = components.get(utils.getParentComponent());\n      var usedPropTypes = (component && component.usedPropTypes || []).slice();\n\n      switch (type) {\n        case 'direct':\n          // Ignore Object methods\n          if (Object.prototype[name]) {\n            break;\n          }\n\n          var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));\n\n          usedPropTypes.push({\n            name: name,\n            allNames: allNames,\n            node: (\n              !isDirectProp && !inConstructor() && !inComponentWillReceiveProps() ? node.parent.property :\n              node.property\n            )\n          });\n          break;\n        case 'destructuring':\n          for (var k = 0, l = properties.length; k < l; k++) {\n            if (hasSpreadOperator(properties[k]) || properties[k].computed) {\n              continue;\n            }\n            var propName = getKeyValue(properties[k]);\n\n            var currentNode = node;\n            allNames = [];\n            while (currentNode.property && !PROPS_REGEX.test(currentNode.property.name)) {\n              allNames.unshift(currentNode.property.name);\n              currentNode = currentNode.object;\n            }\n            allNames.push(propName);\n\n            if (propName) {\n              usedPropTypes.push({\n                name: propName,\n                allNames: allNames,\n                node: properties[k]\n              });\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      components.set(node, {\n        usedPropTypes: usedPropTypes\n      });\n    }\n\n    /**\n     * Mark a prop type as declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {propTypes} node The AST node containing the proptypes\n     */\n    function markPropTypesAsDeclared(node, propTypes) {\n      var componentNode = node;\n      while (componentNode && !components.get(componentNode)) {\n        componentNode = componentNode.parent;\n      }\n      var component = components.get(componentNode);\n      var declaredPropTypes = component && component.declaredPropTypes || {};\n      var ignorePropsValidation = false;\n\n      switch (propTypes && propTypes.type) {\n        case 'ObjectTypeAnnotation':\n          iterateProperties(propTypes.properties, function(key, value) {\n            declaredPropTypes[key] = buildTypeAnnotationDeclarationTypes(value);\n          });\n          break;\n        case 'ObjectExpression':\n          iterateProperties(propTypes.properties, function(key, value) {\n            if (!value) {\n              ignorePropsValidation = true;\n              return;\n            }\n            declaredPropTypes[key] = buildReactDeclarationTypes(value);\n          });\n          break;\n        case 'MemberExpression':\n          var curDeclaredPropTypes = declaredPropTypes;\n          // Walk the list of properties, until we reach the assignment\n          // ie: ClassX.propTypes.a.b.c = ...\n          while (\n            propTypes &&\n            propTypes.parent &&\n            propTypes.parent.type !== 'AssignmentExpression' &&\n            propTypes.property &&\n            curDeclaredPropTypes\n          ) {\n            var propName = propTypes.property.name;\n            if (propName in curDeclaredPropTypes) {\n              curDeclaredPropTypes = curDeclaredPropTypes[propName].children;\n              propTypes = propTypes.parent;\n            } else {\n              // This will crash at runtime because we haven't seen this key before\n              // stop this and do not declare it\n              propTypes = null;\n            }\n          }\n          if (propTypes && propTypes.parent && propTypes.property) {\n            curDeclaredPropTypes[propTypes.property.name] =\n              buildReactDeclarationTypes(propTypes.parent.right);\n          } else {\n            ignorePropsValidation = true;\n          }\n          break;\n        case 'Identifier':\n          var variablesInScope = variable.variablesInScope(context);\n          for (var i = 0, j = variablesInScope.length; i < j; i++) {\n            if (variablesInScope[i].name !== propTypes.name) {\n              continue;\n            }\n            var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];\n            markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);\n            return;\n          }\n          ignorePropsValidation = true;\n          break;\n        case null:\n          break;\n        default:\n          ignorePropsValidation = true;\n          break;\n      }\n\n      components.set(node, {\n        declaredPropTypes: declaredPropTypes,\n        ignorePropsValidation: ignorePropsValidation\n      });\n    }\n\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportUndeclaredPropTypes(component) {\n      var allNames;\n      for (var i = 0, j = component.usedPropTypes.length; i < j; i++) {\n        allNames = component.usedPropTypes[i].allNames;\n        if (\n          isIgnored(allNames[0]) ||\n          isDeclaredInComponent(component.node, allNames)\n        ) {\n          continue;\n        }\n        context.report(\n          component.usedPropTypes[i].node,\n          MISSING_MESSAGE, {\n            name: allNames.join('.').replace(/\\.__COMPUTED_PROP__/g, '[]')\n          }\n        );\n      }\n    }\n\n    /**\n     * Resolve the type annotation for a given node.\n     * Flow annotations are sometimes wrapped in outer `TypeAnnotation`\n     * and `NullableTypeAnnotation` nodes which obscure the annotation we're\n     * interested in.\n     * This method also resolves type aliases where possible.\n     *\n     * @param {ASTNode} node The annotation or a node containing the type annotation.\n     * @returns {ASTNode} The resolved type annotation for the node.\n     */\n    function resolveTypeAnnotation(node) {\n      var annotation = node.typeAnnotation || node;\n      while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n        annotation = annotation.typeAnnotation;\n      }\n      if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {\n        return typeScope(annotation.id.name);\n      }\n      return annotation;\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function markDestructuredFunctionArgumentsAsUsed(node) {\n      var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';\n      if (destructuring && components.get(node)) {\n        markPropTypesAsUsed(node);\n      }\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function markAnnotatedFunctionArgumentsAsDeclared(node) {\n      if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {\n        return;\n      }\n      markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function handleStatelessComponent(node) {\n      markDestructuredFunctionArgumentsAsUsed(node);\n      markAnnotatedFunctionArgumentsAsDeclared(node);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      ClassProperty: function(node) {\n        if (isAnnotatedClassPropsDeclaration(node)) {\n          markPropTypesAsDeclared(node, resolveTypeAnnotation(node));\n        } else if (isPropTypesDeclaration(node)) {\n          markPropTypesAsDeclared(node, node.value);\n        }\n      },\n\n      VariableDeclarator: function(node) {\n        var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';\n        // let {props: {firstname}} = this\n        var thisDestructuring = destructuring && node.init.type === 'ThisExpression';\n        // let {firstname} = props\n        var directDestructuring =\n          destructuring &&\n          PROPS_REGEX.test(node.init.name) &&\n          (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps())\n        ;\n\n        if (!thisDestructuring && !directDestructuring) {\n          return;\n        }\n        markPropTypesAsUsed(node);\n      },\n\n      FunctionDeclaration: handleStatelessComponent,\n\n      ArrowFunctionExpression: handleStatelessComponent,\n\n      FunctionExpression: handleStatelessComponent,\n\n      MemberExpression: function(node) {\n        var type;\n        if (isPropTypesUsage(node)) {\n          type = 'usage';\n        } else if (isPropTypesDeclaration(node.property)) {\n          type = 'declaration';\n        }\n\n        switch (type) {\n          case 'usage':\n            markPropTypesAsUsed(node);\n            break;\n          case 'declaration':\n            var component = utils.getRelatedComponent(node);\n            if (!component) {\n              return;\n            }\n            markPropTypesAsDeclared(component.node, node.parent.right || node.parent);\n            break;\n          default:\n            break;\n        }\n      },\n\n      MethodDefinition: function(node) {\n        if (!isPropTypesDeclaration(node.key)) {\n          return;\n        }\n\n        var i = node.value.body.body.length - 1;\n        for (; i >= 0; i--) {\n          if (node.value.body.body[i].type === 'ReturnStatement') {\n            break;\n          }\n        }\n\n        if (i >= 0) {\n          markPropTypesAsDeclared(node, node.value.body.body[i].argument);\n        }\n      },\n\n      ObjectExpression: function(node) {\n        // Search for the proptypes declaration\n        node.properties.forEach(function(property) {\n          if (!isPropTypesDeclaration(property.key)) {\n            return;\n          }\n          markPropTypesAsDeclared(node, property.value);\n        });\n      },\n\n      TypeAlias: function(node) {\n        typeScope(node.id.name, node.right);\n      },\n\n      Program: function() {\n        stack = [{}];\n      },\n\n      BlockStatement: function () {\n        stack.push(Object.create(typeScope()));\n      },\n\n      'BlockStatement:exit': function () {\n        stack.pop();\n      },\n\n      'Program:exit': function() {\n        stack = null;\n        var list = components.list();\n        // Report undeclared proptypes for all classes\n        for (var component in list) {\n          if (!has(list, component) || !mustBeValidated(list[component])) {\n            continue;\n          }\n          reportUndeclaredPropTypes(list[component]);\n        }\n      }\n    };\n\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/annotations.js":"/**\n * @fileoverview Utility functions for type annotation detection.\n * @author Yannick Croissant\n * @author Vitor Balocco\n */\n'use strict';\n\n/**\n * Checks if we are declaring a `props` argument with a flow type annotation.\n * @param {ASTNode} node The AST node being checked.\n * @returns {Boolean} True if the node is a type annotated props declaration, false if not.\n */\nfunction isAnnotatedFunctionPropsDeclaration(node, context) {\n  if (!node || !node.params || !node.params.length) {\n    return false;\n  }\n\n  var tokens = context.getFirstTokens(node.params[0], 2);\n  var isAnnotated = node.params[0].typeAnnotation;\n  var isDestructuredProps = node.params[0].type === 'ObjectPattern';\n  var isProps = tokens[0].value === 'props' || (tokens[1] && tokens[1].value === 'props');\n\n  return (isAnnotated && (isDestructuredProps || isProps));\n}\n\nmodule.exports = {\n  isAnnotatedFunctionPropsDeclaration: isAnnotatedFunctionPropsDeclaration\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/require-default-props.js":"/**\n * @fileOverview Enforce a defaultProps definition for every prop that is not a required prop.\n * @author Vitor Balocco\n */\n'use strict';\n\nvar has = require('has');\nvar find = require('array.prototype.find');\nvar Components = require('../util/Components');\nvar variableUtil = require('../util/variable');\nvar annotations = require('../util/annotations');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce a defaultProps definition for every prop that is not a required prop.',\n      category: 'Best Practices'\n    },\n\n    schema: []\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n    function getPropertyName(node) {\n      if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n        return node.key.name;\n      } else if (node.type === 'MemberExpression') {\n        return node.property.name;\n      // Special case for class properties\n      // (babel-eslint@5 does not expose property name so we have to rely on tokens)\n      } else if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;\n      }\n      return '';\n    }\n\n    /**\n     * Checks if the Identifier node passed in looks like a propTypes declaration.\n     * @param   {ASTNode}  node The node to check. Must be an Identifier node.\n     * @returns {Boolean}       `true` if the node is a propTypes declaration, `false` if not\n     */\n    function isPropTypesDeclaration(node) {\n      return getPropertyName(node) === 'propTypes';\n    }\n\n    /**\n     * Checks if the Identifier node passed in looks like a defaultProps declaration.\n     * @param   {ASTNode}  node The node to check. Must be an Identifier node.\n     * @returns {Boolean}       `true` if the node is a defaultProps declaration, `false` if not\n     */\n    function isDefaultPropsDeclaration(node) {\n      return (getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps');\n    }\n\n    /**\n     * Checks if the PropTypes MemberExpression node passed in declares a required propType.\n     * @param   {ASTNode} propTypeExpression node to check. Must be a `PropTypes` MemberExpression.\n     * @returns {Boolean}                    `true` if this PropType is required, `false` if not.\n     */\n    function isRequiredPropType(propTypeExpression) {\n      return propTypeExpression.type === 'MemberExpression' && propTypeExpression.property.name === 'isRequired';\n    }\n\n    /**\n     * Find a variable by name in the current scope.\n     * @param  {string} name Name of the variable to look for.\n     * @returns {ASTNode|null} Return null if the variable could not be found, ASTNode otherwise.\n     */\n    function findVariableByName(name) {\n      var variable = find(variableUtil.variablesInScope(context), function(item) {\n        return item.name === name;\n      });\n\n      if (!variable || !variable.defs[0] || !variable.defs[0].node) {\n        return null;\n      }\n\n      if (variable.defs[0].node.type === 'TypeAlias') {\n        return variable.defs[0].node.right;\n      }\n\n      return variable.defs[0].node.init;\n    }\n\n    /**\n     * Try to resolve the node passed in to a variable in the current scope. If the node passed in is not\n     * an Identifier, then the node is simply returned.\n     * @param   {ASTNode} node The node to resolve.\n     * @returns {ASTNode|null} Return null if the value could not be resolved, ASTNode otherwise.\n     */\n    function resolveNodeValue(node) {\n      if (node.type === 'Identifier') {\n        return findVariableByName(node.name);\n      }\n\n      return node;\n    }\n\n    /**\n     * Tries to find the definition of a GenericTypeAnnotation in the current scope.\n     * @param  {ASTNode}      node The node GenericTypeAnnotation node to resolve.\n     * @return {ASTNode|null}      Return null if definition cannot be found, ASTNode otherwise.\n     */\n    function resolveGenericTypeAnnotation(node) {\n      if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {\n        return null;\n      }\n\n      return findVariableByName(node.id.name);\n    }\n\n    function resolveUnionTypeAnnotation(node) {\n      // Go through all the union and resolve any generic types.\n      return node.types.map(function(annotation) {\n        if (annotation.type === 'GenericTypeAnnotation') {\n          return resolveGenericTypeAnnotation(annotation);\n        }\n\n        return annotation;\n      });\n    }\n\n    /**\n     * Extracts a PropType from an ObjectExpression node.\n     * @param   {ASTNode} objectExpression ObjectExpression node.\n     * @returns {Object[]}        Array of PropType object representations, to be consumed by `addPropTypesToComponent`.\n     */\n    function getPropTypesFromObjectExpression(objectExpression) {\n      var props = objectExpression.properties.filter(function(property) {\n        return property.type !== 'ExperimentalSpreadProperty';\n      });\n\n      return props.map(function(property) {\n        return {\n          name: property.key.name,\n          isRequired: isRequiredPropType(property.value),\n          node: property\n        };\n      });\n    }\n\n    /**\n     * Extracts a PropType from a TypeAnnotation node.\n     * @param   {ASTNode} node TypeAnnotation node.\n     * @returns {Object[]}     Array of PropType object representations, to be consumed by `addPropTypesToComponent`.\n     */\n    function getPropTypesFromTypeAnnotation(node) {\n      var properties;\n\n      switch (node.typeAnnotation.type) {\n        case 'GenericTypeAnnotation':\n          var annotation = resolveGenericTypeAnnotation(node.typeAnnotation);\n\n          if (annotation && annotation.id) {\n            annotation = findVariableByName(annotation.id.name);\n          }\n\n          properties = annotation ? (annotation.properties || []) : [];\n          break;\n\n        case 'UnionTypeAnnotation':\n          var union = resolveUnionTypeAnnotation(node.typeAnnotation);\n          properties = union.reduce(function(acc, curr) {\n            if (!curr) {\n              return acc;\n            }\n\n            return acc.concat(curr.properties);\n          }, []);\n          break;\n\n        case 'ObjectTypeAnnotation':\n          properties = node.typeAnnotation.properties;\n          break;\n\n        default:\n          properties = [];\n          break;\n      }\n\n      var props = properties.filter(function(property) {\n        return property.type === 'ObjectTypeProperty';\n      });\n\n      return props.map(function(property) {\n        // the `key` property is not present in ObjectTypeProperty nodes, so we need to get the key name manually.\n        var tokens = context.getFirstTokens(property, 1);\n        var name = tokens[0].value;\n\n        return {\n          name: name,\n          isRequired: !property.optional,\n          node: property\n        };\n      });\n    }\n\n    /**\n     * Extracts a DefaultProp from an ObjectExpression node.\n     * @param   {ASTNode} objectExpression ObjectExpression node.\n     * @returns {Object|string}            Object representation of a defaultProp, to be consumed by\n     *                                     `addDefaultPropsToComponent`, or string \"unresolved\", if the defaultProps\n     *                                     from this ObjectExpression can't be resolved.\n     */\n    function getDefaultPropsFromObjectExpression(objectExpression) {\n      var hasSpread = find(objectExpression.properties, function(property) {\n        return property.type === 'ExperimentalSpreadProperty';\n      });\n\n      if (hasSpread) {\n        return 'unresolved';\n      }\n\n      return objectExpression.properties.map(function(property) {\n        return property.key.name;\n      });\n    }\n\n    /**\n     * Marks a component's DefaultProps declaration as \"unresolved\". A component's DefaultProps is\n     * marked as \"unresolved\" if we cannot safely infer the values of its defaultProps declarations\n     * without risking false negatives.\n     * @param   {Object} component The component to mark.\n     * @returns {void}\n     */\n    function markDefaultPropsAsUnresolved(component) {\n      components.set(component.node, {\n        defaultProps: 'unresolved'\n      });\n    }\n\n    /**\n     * Adds propTypes to the component passed in.\n     * @param   {ASTNode}  component The component to add the propTypes to.\n     * @param   {Object[]} propTypes propTypes to add to the component.\n     * @returns {void}\n     */\n    function addPropTypesToComponent(component, propTypes) {\n      var props = component.propTypes || [];\n\n      components.set(component.node, {\n        propTypes: props.concat(propTypes)\n      });\n    }\n\n    /**\n     * Adds defaultProps to the component passed in.\n     * @param   {ASTNode}         component    The component to add the defaultProps to.\n     * @param   {String[]|String} defaultProps defaultProps to add to the component or the string \"unresolved\"\n     *                                         if this component has defaultProps that can't be resolved.\n     * @returns {void}\n     */\n    function addDefaultPropsToComponent(component, defaultProps) {\n      // Early return if this component's defaultProps is already marked as \"unresolved\".\n      if (component.defaultProps === 'unresolved') {\n        return;\n      }\n\n      if (defaultProps === 'unresolved') {\n        markDefaultPropsAsUnresolved(component);\n        return;\n      }\n\n      var defaults = component.defaultProps || {};\n\n      defaultProps.forEach(function(defaultProp) {\n        defaults[defaultProp] = true;\n      });\n\n      components.set(component.node, {\n        defaultProps: defaults\n      });\n    }\n\n    /**\n     * Tries to find a props type annotation in a stateless component.\n     * @param  {ASTNode} node The AST node to look for a props type annotation.\n     * @return {void}\n     */\n    function handleStatelessComponent(node) {\n      if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {\n        return;\n      }\n\n      // find component this props annotation belongs to\n      var component = components.get(utils.getParentStatelessComponent());\n      if (!component) {\n        return;\n      }\n\n      addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));\n    }\n\n    function handlePropTypeAnnotationClassProperty(node) {\n      // find component this props annotation belongs to\n      var component = components.get(utils.getParentES6Component());\n      if (!component) {\n        return;\n      }\n\n      addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));\n    }\n\n    function isPropTypeAnnotation(node) {\n      return (getPropertyName(node) === 'props' && !!node.typeAnnotation);\n    }\n\n    /**\n     * Reports all propTypes passed in that don't have a defaultProp counterpart.\n     * @param  {Object[]} propTypes    List of propTypes to check.\n     * @param  {Object}   defaultProps Object of defaultProps to check. Keys are the props names.\n     * @return {void}\n     */\n    function reportPropTypesWithoutDefault(propTypes, defaultProps) {\n      // If this defaultProps is \"unresolved\", then we should ignore this component and not report\n      // any errors for it, to avoid false-positives with e.g. external defaultProps declarations or spread operators.\n      if (defaultProps === 'unresolved') {\n        return;\n      }\n\n      propTypes.forEach(function(prop) {\n        if (prop.isRequired) {\n          return;\n        }\n\n        if (defaultProps[prop.name]) {\n          return;\n        }\n\n        context.report(\n          prop.node,\n          'propType \"{{name}}\" is not required, but has no corresponding defaultProp declaration.',\n          {name: prop.name}\n        );\n      });\n    }\n\n    // --------------------------------------------------------------------------\n    // Public API\n    // --------------------------------------------------------------------------\n\n    return {\n      MemberExpression: function(node) {\n        var isPropType = isPropTypesDeclaration(node);\n        var isDefaultProp = isDefaultPropsDeclaration(node);\n\n        if (!isPropType && !isDefaultProp) {\n          return;\n        }\n\n        // find component this propTypes/defaultProps belongs to\n        var component = utils.getRelatedComponent(node);\n        if (!component) {\n          return;\n        }\n\n        // e.g.:\n        // MyComponent.propTypes = {\n        //   foo: React.PropTypes.string.isRequired,\n        //   bar: React.PropTypes.string\n        // };\n        //\n        // or:\n        //\n        // MyComponent.propTypes = myPropTypes;\n        if (node.parent.type === 'AssignmentExpression') {\n\n          var expression = resolveNodeValue(node.parent.right);\n          if (!expression || expression.type !== 'ObjectExpression') {\n            // If a value can't be found, we mark the defaultProps declaration as \"unresolved\", because\n            // we should ignore this component and not report any errors for it, to avoid false-positives\n            // with e.g. external defaultProps declarations.\n            if (isDefaultProp) {\n              markDefaultPropsAsUnresolved(component);\n            }\n\n            return;\n          }\n\n          if (isPropType) {\n            addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));\n          } else {\n            addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n          }\n\n          return;\n        }\n\n        // e.g.:\n        // MyComponent.propTypes.baz = React.PropTypes.string;\n        if (node.parent.type === 'MemberExpression' && node.parent.parent.type === 'AssignmentExpression') {\n\n          if (isPropType) {\n            addPropTypesToComponent(component, [{\n              name: node.parent.property.name,\n              isRequired: isRequiredPropType(node.parent.parent.right),\n              node: node.parent.parent\n            }]);\n          } else {\n            addDefaultPropsToComponent(component, [node.parent.property.name]);\n          }\n\n          return;\n        }\n      },\n\n      // e.g.:\n      // class Hello extends React.Component {\n      //   static get propTypes() {\n      //     return {\n      //       name: React.PropTypes.string\n      //     };\n      //   }\n      //   static get defaultProps() {\n      //     return {\n      //       name: 'Dean'\n      //     };\n      //   }\n      //   render() {\n      //     return <div>Hello {this.props.name}</div>;\n      //   }\n      // }\n      MethodDefinition: function(node) {\n        if (!node.static || node.kind !== 'get') {\n          return;\n        }\n\n        var isPropType = isPropTypesDeclaration(node);\n        var isDefaultProp = isDefaultPropsDeclaration(node);\n\n        if (!isPropType && !isDefaultProp) {\n          return;\n        }\n\n        // find component this propTypes/defaultProps belongs to\n        var component = components.get(utils.getParentES6Component());\n        if (!component) {\n          return;\n        }\n\n        var returnStatement = utils.findReturnStatement(node);\n        if (!returnStatement) {\n          return;\n        }\n\n        var expression = resolveNodeValue(returnStatement.argument);\n        if (!expression || expression.type !== 'ObjectExpression') {\n          return;\n        }\n\n        if (isPropType) {\n          addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));\n        } else {\n          addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n        }\n      },\n\n      // e.g.:\n      // class Greeting extends React.Component {\n      //   render() {\n      //     return (\n      //       <h1>Hello, {this.props.foo} {this.props.bar}</h1>\n      //     );\n      //   }\n      //   static propTypes = {\n      //     foo: React.PropTypes.string,\n      //     bar: React.PropTypes.string.isRequired\n      //   };\n      // }\n      ClassProperty: function(node) {\n        if (isPropTypeAnnotation(node)) {\n          handlePropTypeAnnotationClassProperty(node);\n          return;\n        }\n\n        if (!node.static) {\n          return;\n        }\n\n        if (!node.value) {\n          return;\n        }\n\n        var isPropType = getPropertyName(node) === 'propTypes';\n        var isDefaultProp = getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps';\n\n        if (!isPropType && !isDefaultProp) {\n          return;\n        }\n\n        // find component this propTypes/defaultProps belongs to\n        var component = components.get(utils.getParentES6Component());\n        if (!component) {\n          return;\n        }\n\n        var expression = resolveNodeValue(node.value);\n        if (!expression || expression.type !== 'ObjectExpression') {\n          return;\n        }\n\n        if (isPropType) {\n          addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));\n        } else {\n          addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n        }\n      },\n\n      // e.g.:\n      // React.createClass({\n      //   render: function() {\n      //     return <div>{this.props.foo}</div>;\n      //   },\n      //   propTypes: {\n      //     foo: React.PropTypes.string.isRequired,\n      //   },\n      //   getDefaultProps: function() {\n      //     return {\n      //       foo: 'default'\n      //     };\n      //   }\n      // });\n      ObjectExpression: function(node) {\n        // find component this propTypes/defaultProps belongs to\n        var component = utils.isES5Component(node) && components.get(node);\n        if (!component) {\n          return;\n        }\n\n        // Search for the proptypes declaration\n        node.properties.forEach(function(property) {\n          if (property.type === 'ExperimentalSpreadProperty') {\n            return;\n          }\n\n          var isPropType = isPropTypesDeclaration(property);\n          var isDefaultProp = isDefaultPropsDeclaration(property);\n\n          if (!isPropType && !isDefaultProp) {\n            return;\n          }\n\n          if (isPropType && property.value.type === 'ObjectExpression') {\n            addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));\n            return;\n          }\n\n          if (isDefaultProp && property.value.type === 'FunctionExpression') {\n            var returnStatement = utils.findReturnStatement(property);\n            if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {\n              return;\n            }\n\n            addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));\n          }\n        });\n      },\n\n      // Check for type annotations in stateless components\n      FunctionDeclaration: handleStatelessComponent,\n      ArrowFunctionExpression: handleStatelessComponent,\n      FunctionExpression: handleStatelessComponent,\n\n      'Program:exit': function() {\n        var list = components.list();\n\n        for (var component in list) {\n          if (!has(list, component)) {\n            continue;\n          }\n\n          // If no propTypes could be found, we don't report anything.\n          if (!list[component].propTypes) {\n            return;\n          }\n\n          reportPropTypesWithoutDefault(\n            list[component].propTypes,\n            list[component].defaultProps || {}\n          );\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/display-name.js":"/**\n * @fileoverview Prevent missing displayName in a React component definition\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent missing displayName in a React component definition',\n      category: 'Best Practices',\n      recommended: true\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreTranspilerName: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    var sourceCode = context.getSourceCode();\n    var config = context.options[0] || {};\n    var ignoreTranspilerName = config.ignoreTranspilerName || false;\n\n    var MISSING_MESSAGE = 'Component definition is missing display name';\n\n    /**\n     * Checks if we are declaring a display name\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a display name, false if not.\n     */\n    function isDisplayNameDeclaration(node) {\n      switch (node.type) {\n        // Special case for class properties\n        // (babel-eslint does not expose property name so we have to rely on tokens)\n        case 'ClassProperty':\n          var tokens = sourceCode.getFirstTokens(node, 2);\n          if (\n            tokens[0].value === 'displayName' ||\n            (tokens[1] && tokens[1].value === 'displayName')\n          ) {\n            return true;\n          }\n          return false;\n        case 'Identifier':\n          return node.name === 'displayName';\n        case 'Literal':\n          return node.value === 'displayName';\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Mark a prop type as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markDisplayNameAsDeclared(node) {\n      components.set(node, {\n        hasDisplayName: true\n      });\n    }\n\n    /**\n     * Reports missing display name for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMissingDisplayName(component) {\n      context.report({\n        node: component.node,\n        message: MISSING_MESSAGE,\n        data: {\n          component: component.name\n        }\n      });\n    }\n\n    /**\n     * Checks if the component have a name set by the transpiler\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if component has a name, false if not.\n     */\n    function hasTranspilerName(node) {\n      var namedObjectAssignment = (\n        node.type === 'ObjectExpression' &&\n        node.parent &&\n        node.parent.parent &&\n        node.parent.parent.type === 'AssignmentExpression' && (\n          !node.parent.parent.left.object ||\n          node.parent.parent.left.object.name !== 'module' ||\n          node.parent.parent.left.property.name !== 'exports'\n        )\n      );\n      var namedObjectDeclaration = (\n          node.type === 'ObjectExpression' &&\n          node.parent &&\n          node.parent.parent &&\n          node.parent.parent.type === 'VariableDeclarator'\n      );\n      var namedClass = (\n        (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') &&\n        node.id &&\n        node.id.name\n      );\n\n      var namedFunctionDeclaration = (\n        (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') &&\n        node.id &&\n        node.id.name\n      );\n\n      var namedFunctionExpression = (\n        (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') &&\n        node.parent &&\n        (node.parent.type === 'VariableDeclarator' || node.parent.method === true) &&\n        (!node.parent.parent || !utils.isES5Component(node.parent.parent))\n      );\n\n      if (\n        namedObjectAssignment || namedObjectDeclaration ||\n        namedClass ||\n        namedFunctionDeclaration || namedFunctionExpression\n      ) {\n        return true;\n      }\n      return false;\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      ClassProperty: function(node) {\n        if (!isDisplayNameDeclaration(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      MemberExpression: function(node) {\n        if (!isDisplayNameDeclaration(node.property)) {\n          return;\n        }\n        var component = utils.getRelatedComponent(node);\n        if (!component) {\n          return;\n        }\n        markDisplayNameAsDeclared(component.node);\n      },\n\n      FunctionExpression: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      FunctionDeclaration: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      ArrowFunctionExpression: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      MethodDefinition: function(node) {\n        if (!isDisplayNameDeclaration(node.key)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      ClassExpression: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      ClassDeclaration: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      ObjectExpression: function(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          // Search for the displayName declaration\n          node.properties.forEach(function(property) {\n            if (!property.key || !isDisplayNameDeclaration(property.key)) {\n              return;\n            }\n            markDisplayNameAsDeclared(node);\n          });\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      'Program:exit': function() {\n        var list = components.list();\n        // Report missing display name for all components\n        for (var component in list) {\n          if (!has(list, component) || list[component].hasDisplayName) {\n            continue;\n          }\n          reportMissingDisplayName(list[component]);\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-wrap-multilines.js":"/**\n * @fileoverview Prevent missing parentheses around multilines JSX\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = {\n  declaration: true,\n  assignment: true,\n  return: true\n};\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent missing parentheses around multilines JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      type: 'object',\n      properties: {\n        declaration: {\n          type: 'boolean'\n        },\n        assignment: {\n          type: 'boolean'\n        },\n        return: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var sourceCode = context.getSourceCode();\n\n    function isParenthesised(node) {\n      var previousToken = sourceCode.getTokenBefore(node);\n      var nextToken = sourceCode.getTokenAfter(node);\n\n      return previousToken && nextToken &&\n        previousToken.value === '(' && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n    }\n\n    function isMultilines(node) {\n      return node.loc.start.line !== node.loc.end.line;\n    }\n\n    function check(node) {\n      if (!node || node.type !== 'JSXElement') {\n        return;\n      }\n\n      if (!isParenthesised(node) && isMultilines(node)) {\n        context.report({\n          node: node,\n          message: 'Missing parentheses around multilines JSX',\n          fix: function(fixer) {\n            return fixer.replaceText(node, '(' + sourceCode.getText(node) + ')');\n          }\n        });\n      }\n    }\n\n    function isEnabled(type) {\n      var userOptions = context.options[0] || {};\n      if (has(userOptions, type)) {\n        return userOptions[type];\n      }\n      return DEFAULTS[type];\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      VariableDeclarator: function(node) {\n        if (!isEnabled('declaration')) {\n          return;\n        }\n        if (node.init && node.init.type === 'ConditionalExpression') {\n          check(node.init.consequent);\n          check(node.init.alternate);\n          return;\n        }\n        check(node.init);\n      },\n\n      AssignmentExpression: function(node) {\n        if (!isEnabled('assignment')) {\n          return;\n        }\n        if (node.right.type === 'ConditionalExpression') {\n          check(node.right.consequent);\n          check(node.right.alternate);\n          return;\n        }\n        check(node.right);\n      },\n\n      ReturnStatement: function(node) {\n        if (isEnabled('return')) {\n          check(node.argument);\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js":"/**\n * @fileoverview Prevent extra closing tags for components without children\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent extra closing tags for components without children',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      type: 'object',\n      properties: {\n        component: {\n          default: true,\n          type: 'boolean'\n        },\n        html: {\n          default: true,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var tagConvention = /^[a-z]|\\-/;\n    function isTagName(name) {\n      return tagConvention.test(name);\n    }\n\n    function isComponent(node) {\n      return node.name && node.name.type === 'JSXIdentifier' && !isTagName(node.name.name);\n    }\n\n    function hasChildren(node) {\n      var childrens = node.parent.children;\n      if (\n        !childrens.length ||\n        (childrens.length === 1 && childrens[0].type === 'Literal' && !childrens[0].value.replace(/(?!\\xA0)\\s/g, ''))\n      ) {\n        return false;\n      }\n      return true;\n    }\n\n    function isShouldBeSelfClosed(node) {\n      var configuration = context.options[0] || {component: true, html: true};\n      return (\n        configuration.component && isComponent(node) ||\n        configuration.html && isTagName(node.name.name)\n      ) && !node.selfClosing && !hasChildren(node);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      JSXOpeningElement: function(node) {\n\n        if (!isShouldBeSelfClosed(node)) {\n          return;\n        }\n        context.report({\n          node: node,\n          message: 'Empty components are self-closing',\n          fix: function(fixer) {\n            // Represents the last character of the JSXOpeningElement, the '>' character\n            var openingElementEnding = node.end - 1;\n            // Represents the last character of the JSXClosingElement, the '>' character\n            var closingElementEnding = node.parent.closingElement.end;\n\n            // Replace />.*<\\/.*>/ with '/>'\n            var range = [openingElementEnding, closingElementEnding];\n            return fixer.replaceTextRange(range, ' />');\n          }\n        });\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-comment-textnodes.js":"/**\n * @fileoverview Comments inside children section of tag should be placed inside braces.\n * @author Ben Vinegar\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Comments inside children section of tag should be placed inside braces',\n      category: 'Possible Errors',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {},\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n    function reportLiteralNode(node) {\n      context.report(node, 'Comments inside children section of tag should be placed inside braces');\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      Literal: function(node) {\n        if (/^\\s*\\/(\\/|\\*)/m.test(node.value)) {\n          // inside component, e.g. <div>literal</div>\n          if (node.parent.type !== 'JSXAttribute' &&\n              node.parent.type !== 'JSXExpressionContainer' &&\n              node.parent.type.indexOf('JSX') !== -1) {\n            reportLiteralNode(node);\n          }\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-array-index-key.js":"/**\n * @fileoverview Prevent usage of Array index in keys\n * @author Joe Lencioni\n */\n'use strict';\n\nvar has = require('has');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of Array index in keys',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: []\n  },\n\n  create: function(context) {\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    var indexParamNames = [];\n    var iteratorFunctionsToIndexParamPosition = {\n      every: 1,\n      filter: 1,\n      find: 1,\n      findIndex: 1,\n      forEach: 1,\n      map: 1,\n      reduce: 2,\n      reduceRight: 2,\n      some: 1\n    };\n    var ERROR_MESSAGE = 'Do not use Array index in keys';\n\n    function isArrayIndex(node) {\n      return node.type === 'Identifier'\n        && indexParamNames.indexOf(node.name) !== -1;\n    }\n\n    function getMapIndexParamName(node) {\n      var callee = node.callee;\n      if (callee.type !== 'MemberExpression') {\n        return null;\n      }\n      if (callee.property.type !== 'Identifier') {\n        return null;\n      }\n      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {\n        return null;\n      }\n\n      var firstArg = node.arguments[0];\n      if (!firstArg) {\n        return null;\n      }\n\n      var isFunction = [\n        'ArrowFunctionExpression',\n        'FunctionExpression'\n      ].indexOf(firstArg.type) !== -1;\n      if (!isFunction) {\n        return null;\n      }\n\n      var params = firstArg.params;\n\n      var indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];\n      if (params.length < indexParamPosition + 1) {\n        return null;\n      }\n\n      return params[indexParamPosition].name;\n    }\n\n    function getIdentifiersFromBinaryExpression(side) {\n      if (side.type === 'Identifier') {\n        return side;\n      }\n\n      if (side.type === 'BinaryExpression') {\n        // recurse\n        var left = getIdentifiersFromBinaryExpression(side.left);\n        var right = getIdentifiersFromBinaryExpression(side.right);\n        return [].concat(left, right).filter(Boolean);\n      }\n\n      return null;\n    }\n\n    function checkPropValue(node) {\n      if (isArrayIndex(node)) {\n        // key={bar}\n        context.report({\n          node: node,\n          message: ERROR_MESSAGE\n        });\n        return;\n      }\n\n      if (node.type === 'TemplateLiteral') {\n        // key={`foo-${bar}`}\n        node.expressions.filter(isArrayIndex).forEach(function() {\n          context.report({node: node, message: ERROR_MESSAGE});\n        });\n\n        return;\n      }\n\n      if (node.type === 'BinaryExpression') {\n        // key={'foo' + bar}\n        var identifiers = getIdentifiersFromBinaryExpression(node);\n\n        identifiers.filter(isArrayIndex).forEach(function() {\n          context.report({node: node, message: ERROR_MESSAGE});\n        });\n\n        return;\n      }\n    }\n\n    return {\n      CallExpression: function(node) {\n        if (\n          node.callee\n          && node.callee.type === 'MemberExpression'\n          && ['createElement', 'cloneElement'].indexOf(node.callee.property.name) !== -1\n          && node.arguments.length > 1\n        ) {\n          // React.createElement\n          if (!indexParamNames.length) {\n            return;\n          }\n\n          var props = node.arguments[1];\n\n          if (props.type !== 'ObjectExpression') {\n            return;\n          }\n\n          props.properties.forEach(function (prop) {\n            if (!prop.key || prop.key.name !== 'key') {\n              // { ...foo }\n              // { foo: bar }\n              return;\n            }\n\n            checkPropValue(prop.value);\n          });\n\n          return;\n        }\n\n        var mapIndexParamName = getMapIndexParamName(node);\n        if (!mapIndexParamName) {\n          return;\n        }\n\n        indexParamNames.push(mapIndexParamName);\n      },\n\n      JSXAttribute: function(node) {\n        if (node.name.name !== 'key') {\n          // foo={bar}\n          return;\n        }\n\n        if (!indexParamNames.length) {\n          // Not inside a call expression that we think has an index param.\n          return;\n        }\n\n        var value = node.value;\n        if (value.type !== 'JSXExpressionContainer') {\n          // key='foo'\n          return;\n        }\n\n        checkPropValue(value.expression);\n      },\n\n      'CallExpression:exit': function(node) {\n        var mapIndexParamName = getMapIndexParamName(node);\n        if (!mapIndexParamName) {\n          return;\n        }\n\n        indexParamNames.pop();\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-danger.js":"/**\n * @fileoverview Prevent usage of dangerous JSX props\n * @author Scott Andrews\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DANGEROUS_MESSAGE = 'Dangerous property \\'{{name}}\\' found';\n\nvar DANGEROUS_PROPERTY_NAMES = [\n  'dangerouslySetInnerHTML'\n];\n\nvar DANGEROUS_PROPERTIES = DANGEROUS_PROPERTY_NAMES.reduce(function (props, prop) {\n  props[prop] = prop;\n  return props;\n}, Object.create(null));\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n/**\n * Checks if a node name match the JSX tag convention.\n * @param {String} name - Name of the node to check.\n * @returns {boolean} Whether or not the node name match the JSX tag convention.\n */\nvar tagConvention = /^[a-z]|\\-/;\nfunction isTagName(name) {\n  return tagConvention.test(name);\n}\n\n/**\n * Checks if a JSX attribute is dangerous.\n * @param {String} name - Name of the attribute to check.\n * @returns {boolean} Whether or not the attribute is dnagerous.\n */\nfunction isDangerous(name) {\n  return name in DANGEROUS_PROPERTIES;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of dangerous JSX props',\n      category: 'Best Practices',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    return {\n\n      JSXAttribute: function(node) {\n        if (isTagName(node.parent.name.name) && isDangerous(node.name.name)) {\n          context.report({\n            node: node,\n            message: DANGEROUS_MESSAGE,\n            data: {\n              name: node.name.name\n            }\n          });\n        }\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-set-state.js":"/**\n * @fileoverview Prevent usage of setState\n * @author Mark Dalgleish\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of setState',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    /**\n     * Checks if the component is valid\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component is valid, false if not.\n     */\n    function isValid(component) {\n      return Boolean(component && !component.useSetState);\n    }\n\n    /**\n     * Reports usages of setState for a given component\n     * @param {Object} component The component to process\n     */\n    function reportSetStateUsages(component) {\n      var setStateUsage;\n      for (var i = 0, j = component.setStateUsages.length; i < j; i++) {\n        setStateUsage = component.setStateUsages[i];\n        context.report({\n          node: setStateUsage,\n          message: 'Do not use setState'\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n        if (\n          callee.type !== 'MemberExpression' ||\n          callee.object.type !== 'ThisExpression' ||\n          callee.property.name !== 'setState'\n        ) {\n          return;\n        }\n        var component = components.get(utils.getParentComponent());\n        var setStateUsages = component && component.setStateUsages || [];\n        setStateUsages.push(callee);\n        components.set(node, {\n          useSetState: true,\n          setStateUsages: setStateUsages\n        });\n      },\n\n      'Program:exit': function() {\n        var list = components.list();\n        for (var component in list) {\n          if (!has(list, component) || isValid(list[component])) {\n            continue;\n          }\n          reportSetStateUsages(list[component]);\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js":"/**\n * @fileoverview Prevent usage of isMounted\n * @author Joe Lencioni\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of isMounted',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n        if (callee.type !== 'MemberExpression') {\n          return;\n        }\n        if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'isMounted') {\n          return;\n        }\n        var ancestors = context.getAncestors(callee);\n        for (var i = 0, j = ancestors.length; i < j; i++) {\n          if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {\n            context.report({\n              node: callee,\n              message: 'Do not use isMounted'\n            });\n            break;\n          }\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js":"/**\n * @fileoverview Prevent usage of deprecated methods\n * @author Yannick Croissant\n * @author Scott Feeney\n */\n'use strict';\n\nvar pragmaUtil = require('../util/pragma');\nvar versionUtil = require('../util/version');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEPRECATED_MESSAGE = '{{oldMethod}} is deprecated since React {{version}}{{newMethod}}';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of deprecated methods',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    var sourceCode = context.getSourceCode();\n    var pragma = pragmaUtil.getFromContext(context);\n\n    function getDeprecated() {\n      var deprecated = {\n        MemberExpression: {}\n      };\n      // 0.12.0\n      deprecated.MemberExpression[pragma + '.renderComponent'] = ['0.12.0', pragma + '.render'];\n      deprecated.MemberExpression[pragma + '.renderComponentToString'] = ['0.12.0', pragma + '.renderToString'];\n      deprecated.MemberExpression[pragma + '.renderComponentToStaticMarkup'] = [\n        '0.12.0',\n        pragma + '.renderToStaticMarkup'\n      ];\n      deprecated.MemberExpression[pragma + '.isValidComponent'] = ['0.12.0', pragma + '.isValidElement'];\n      deprecated.MemberExpression[pragma + '.PropTypes.component'] = ['0.12.0', pragma + '.PropTypes.element'];\n      deprecated.MemberExpression[pragma + '.PropTypes.renderable'] = ['0.12.0', pragma + '.PropTypes.node'];\n      deprecated.MemberExpression[pragma + '.isValidClass'] = ['0.12.0'];\n      deprecated.MemberExpression['this.transferPropsTo'] = ['0.12.0', 'spread operator ({...})'];\n      // 0.13.0\n      deprecated.MemberExpression[pragma + '.addons.classSet'] = ['0.13.0', 'the npm module classnames'];\n      deprecated.MemberExpression[pragma + '.addons.cloneWithProps'] = ['0.13.0', pragma + '.cloneElement'];\n      // 0.14.0\n      deprecated.MemberExpression[pragma + '.render'] = ['0.14.0', 'ReactDOM.render'];\n      deprecated.MemberExpression[pragma + '.unmountComponentAtNode'] = ['0.14.0', 'ReactDOM.unmountComponentAtNode'];\n      deprecated.MemberExpression[pragma + '.findDOMNode'] = ['0.14.0', 'ReactDOM.findDOMNode'];\n      deprecated.MemberExpression[pragma + '.renderToString'] = ['0.14.0', 'ReactDOMServer.renderToString'];\n      deprecated.MemberExpression[pragma + '.renderToStaticMarkup'] = ['0.14.0', 'ReactDOMServer.renderToStaticMarkup'];\n      // 15.0.0\n      deprecated.MemberExpression[pragma + '.addons.LinkedStateMixin'] = ['15.0.0'];\n      deprecated.MemberExpression['ReactPerf.printDOM'] = ['15.0.0', 'ReactPerf.printOperations'];\n      deprecated.MemberExpression['Perf.printDOM'] = ['15.0.0', 'Perf.printOperations'];\n      deprecated.MemberExpression['ReactPerf.getMeasurementsSummaryMap'] = ['15.0.0', 'ReactPerf.getWasted'];\n      deprecated.MemberExpression['Perf.getMeasurementsSummaryMap'] = ['15.0.0', 'Perf.getWasted'];\n\n      return deprecated;\n    }\n\n    function isDeprecated(type, method) {\n      var deprecated = getDeprecated();\n\n      return (\n        deprecated[type] &&\n        deprecated[type][method] &&\n        versionUtil.test(context, deprecated[type][method][0])\n      );\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      MemberExpression: function(node) {\n        var method = sourceCode.getText(node);\n        if (!isDeprecated(node.type, method)) {\n          return;\n        }\n        var deprecated = getDeprecated();\n        context.report({\n          node: node,\n          message: DEPRECATED_MESSAGE,\n          data: {\n            oldMethod: method,\n            version: deprecated[node.type][method][0],\n            newMethod: deprecated[node.type][method][1] ? ', use ' + deprecated[node.type][method][1] + ' instead' : ''\n          }\n        });\n      },\n\n      BlockComment: function(node) {\n        pragma = pragmaUtil.getFromNode(node) || pragma;\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/version.js":"/**\n * @fileoverview Utility functions for React version configuration\n * @author Yannick Croissant\n */\n'use strict';\n\nfunction getFromContext(context) {\n  var confVer = '999.999.999';\n  // .eslintrc shared settings (http://eslint.org/docs/user-guide/configuring#adding-shared-settings)\n  if (context.settings.react && context.settings.react.version) {\n    confVer = context.settings.react.version;\n  }\n  confVer = /^[0-9]+\\.[0-9]+$/.test(confVer) ? confVer + '.0' : confVer;\n  return confVer.split('.').map(function(part) {\n    return Number(part);\n  });\n}\n\nfunction test(context, methodVer) {\n  var confVer = getFromContext(context);\n  methodVer = methodVer.split('.').map(function(part) {\n    return Number(part);\n  });\n  var higherMajor = methodVer[0] < confVer[0];\n  var higherMinor = methodVer[0] === confVer[0] && methodVer[1] < confVer[1];\n  var higherOrEqualPatch = methodVer[0] === confVer[0] && methodVer[1] === confVer[1] && methodVer[2] <= confVer[2];\n\n  return higherMajor || higherMinor || higherOrEqualPatch;\n}\n\nmodule.exports = {\n  test: test\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js":"/**\n * @fileoverview Prevent usage of setState in componentDidMount\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of setState in componentDidMount',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      enum: ['disallow-in-func']\n    }]\n  },\n\n  create: function(context) {\n\n    var mode = context.options[0] || 'allow-in-func';\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n        if (\n          callee.type !== 'MemberExpression' ||\n          callee.object.type !== 'ThisExpression' ||\n          callee.property.name !== 'setState'\n        ) {\n          return;\n        }\n        var ancestors = context.getAncestors(callee).reverse();\n        var depth = 0;\n        for (var i = 0, j = ancestors.length; i < j; i++) {\n          if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {\n            depth++;\n          }\n          if (\n            (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||\n            ancestors[i].key.name !== 'componentDidMount' ||\n            (mode !== 'disallow-in-func' && depth > 1)\n          ) {\n            continue;\n          }\n          context.report({\n            node: callee,\n            message: 'Do not use setState in componentDidMount'\n          });\n          break;\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js":"/**\n * @fileoverview Prevent usage of setState in componentDidUpdate\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of setState in componentDidUpdate',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      enum: ['disallow-in-func']\n    }]\n  },\n\n  create: function(context) {\n\n    var mode = context.options[0] || 'allow-in-func';\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n        if (\n          callee.type !== 'MemberExpression' ||\n          callee.object.type !== 'ThisExpression' ||\n          callee.property.name !== 'setState'\n        ) {\n          return;\n        }\n        var ancestors = context.getAncestors(callee).reverse();\n        var depth = 0;\n        for (var i = 0, j = ancestors.length; i < j; i++) {\n          if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {\n            depth++;\n          }\n          if (\n            (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||\n            ancestors[i].key.name !== 'componentDidUpdate' ||\n            (mode !== 'disallow-in-func' && depth > 1)\n          ) {\n            continue;\n          }\n          context.report({\n            node: callee,\n            message: 'Do not use setState in componentDidUpdate'\n          });\n          break;\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-render-return-value.js":"/**\n * @fileoverview Prevent usage of the return value of React.render\n * @author Dustan Kasten\n */\n'use strict';\n\nvar versionUtil = require('../util/version');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of the return value of React.render',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n        var parent = node.parent;\n        if (callee.type !== 'MemberExpression') {\n          return;\n        }\n\n        var calleeObjectName = /^ReactDOM$/;\n        if (versionUtil.test(context, '15.0.0')) {\n          calleeObjectName = /^ReactDOM$/;\n        } else if (versionUtil.test(context, '0.14.0')) {\n          calleeObjectName = /^React(DOM)?$/;\n        } else if (versionUtil.test(context, '0.13.0')) {\n          calleeObjectName = /^React$/;\n        }\n\n        if (\n          callee.object.type !== 'Identifier' ||\n          !calleeObjectName.test(callee.object.name) ||\n          callee.property.name !== 'render'\n        ) {\n          return;\n        }\n\n        if (\n          parent.type === 'VariableDeclarator' ||\n          parent.type === 'Property' ||\n          parent.type === 'ReturnStatement' ||\n          parent.type === 'ArrowFunctionExpression'\n        ) {\n          context.report({\n            node: callee,\n            message: 'Do not depend on the return value from ' + callee.object.name + '.render'\n          });\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-unescaped-entities.js":"/**\n * @fileoverview HTML special characters should be escaped.\n * @author Patrick Hayes\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n// NOTE: '<' and '{' are also problematic characters, but they do not need\n// to be included here because it is a syntax error when these characters are\n// included accidentally.\nvar DEFAULTS = ['>', '\"', '\\'', '}'];\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Detect unescaped HTML entities, which might represent malformed tags',\n      category: 'Possible Errors',\n      recommended: false\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        forbid: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n    function isInvalidEntity(node) {\n      var configuration = context.options[0] || {};\n      var entities = configuration.forbid || DEFAULTS;\n\n      // HTML entites are already escaped in node.value (as well as node.raw),\n      // so pull the raw text from context.getSourceCode()\n      for (var i = node.loc.start.line; i <= node.loc.end.line; i++) {\n        var rawLine = context.getSourceCode().lines[i - 1];\n        var start = 0;\n        var end = rawLine.length;\n        if (i === node.loc.start.line) {\n          start = node.loc.start.column;\n        }\n        if (i === node.loc.end.line) {\n          end = node.loc.end.column;\n        }\n        rawLine = rawLine.substring(start, end);\n        for (var j = 0; j < entities.length; j++) {\n          for (var index = 0; index < rawLine.length; index++) {\n            var c = rawLine[index];\n            if (c === entities[j]) {\n              context.report({\n                loc: {line: i, column: start + index},\n                message: 'HTML entities must be escaped.',\n                node: node\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      Literal: function(node) {\n        if (node.type === 'Literal' && node.parent.type === 'JSXElement') {\n          if (isInvalidEntity(node)) {\n            context.report(node, 'HTML entities must be escaped.');\n          }\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js":"/**\n * @fileoverview Prevent missing React when using JSX\n * @author Glen Mailer\n */\n'use strict';\n\nvar variableUtil = require('../util/variable');\nvar pragmaUtil = require('../util/pragma');\n\n// -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent missing React when using JSX',\n      category: 'Possible Errors',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    var pragma = pragmaUtil.getFromContext(context);\n    var NOT_DEFINED_MESSAGE = '\\'{{name}}\\' must be in scope when using JSX';\n\n    return {\n\n      JSXOpeningElement: function(node) {\n        var variables = variableUtil.variablesInScope(context);\n        if (variableUtil.findVariable(variables, pragma)) {\n          return;\n        }\n        context.report({\n          node: node,\n          message: NOT_DEFINED_MESSAGE,\n          data: {\n            name: pragma\n          }\n        });\n      },\n\n      BlockComment: function(node) {\n        pragma = pragmaUtil.getFromNode(node) || pragma;\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js":"/**\n * @fileoverview Prevent variables used in JSX to be marked as unused\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent variables used in JSX to be marked as unused',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    return {\n      JSXOpeningElement: function(node) {\n        var name;\n        if (node.name.namespace && node.name.namespace.name) {\n          // <Foo:Bar>\n          name = node.name.namespace.name;\n        } else if (node.name.name) {\n          // <Foo>\n          name = node.name.name;\n        } else if (node.name.object) {\n          // <Foo...Bar>\n          var parent = node.name.object;\n          while (parent.object) {\n            parent = parent.object;\n          }\n          name = parent.name;\n        } else {\n          return;\n        }\n\n        context.markVariableAsUsed(name);\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js":"/**\n * @fileoverview Enforce event handler naming conventions in JSX\n * @author Jake Marsh\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce event handler naming conventions in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        eventHandlerPrefix: {\n          type: 'string'\n        },\n        eventHandlerPropPrefix: {\n          type: 'string'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var sourceCode = context.getSourceCode();\n    var configuration = context.options[0] || {};\n    var eventHandlerPrefix = configuration.eventHandlerPrefix || 'handle';\n    var eventHandlerPropPrefix = configuration.eventHandlerPropPrefix || 'on';\n\n    var EVENT_HANDLER_REGEX = new RegExp('^((props\\\\.' + eventHandlerPropPrefix + ')'\n                                        + '|((.*\\\\.)?' + eventHandlerPrefix + '))[A-Z].*$');\n    var PROP_EVENT_HANDLER_REGEX = new RegExp('^(' + eventHandlerPropPrefix + '[A-Z].*|ref)$');\n\n    return {\n      JSXAttribute: function(node) {\n        if (!node.value || !node.value.expression || !node.value.expression.object) {\n          return;\n        }\n\n        var propKey = typeof node.name === 'object' ? node.name.name : node.name;\n        var propValue = sourceCode.getText(node.value.expression).replace(/^this\\.|.*::/, '');\n\n        if (propKey === 'ref') {\n          return;\n        }\n\n        var propIsEventHandler = PROP_EVENT_HANDLER_REGEX.test(propKey);\n        var propFnIsNamedCorrectly = EVENT_HANDLER_REGEX.test(propValue);\n\n        if (propIsEventHandler && !propFnIsNamedCorrectly) {\n          context.report({\n            node: node,\n            message: 'Handler function for ' + propKey + ' prop key must begin with \\'' + eventHandlerPrefix + '\\''\n          });\n        } else if (propFnIsNamedCorrectly && !propIsEventHandler) {\n          context.report({\n            node: node,\n            message: 'Prop key for ' + propValue + ' must begin with \\'' + eventHandlerPropPrefix + '\\''\n          });\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js":"/**\n * @fileoverview Enforce PascalCase for user-defined JSX components\n * @author Jake Marsh\n */\n\n'use strict';\n\nvar elementType = require('jsx-ast-utils/elementType');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar PASCAL_CASE_REGEX = /^([A-Z0-9]|[A-Z0-9]+[a-z0-9]+(?:[A-Z0-9]+[a-z0-9]*)*)$/;\nvar COMPAT_TAG_REGEX = /^[a-z]|\\-/;\nvar ALL_CAPS_TAG_REGEX = /^[A-Z0-9]+$/;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce PascalCase for user-defined JSX components',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowAllCaps: {\n          type: 'boolean'\n        },\n        ignore: {\n          type: 'array'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var configuration = context.options[0] || {};\n    var allowAllCaps = configuration.allowAllCaps || false;\n    var ignore = configuration.ignore || [];\n\n    return {\n      JSXOpeningElement: function(node) {\n        var name = elementType(node);\n\n        // Get namespace if the type is JSXNamespacedName or JSXMemberExpression\n        if (name.indexOf(':') > -1) {\n          name = name.substring(0, name.indexOf(':'));\n        } else if (name.indexOf('.') > -1) {\n          name = name.substring(0, name.indexOf('.'));\n        }\n\n        var isPascalCase = PASCAL_CASE_REGEX.test(name);\n        var isCompatTag = COMPAT_TAG_REGEX.test(name);\n        var isAllowedAllCaps = allowAllCaps && ALL_CAPS_TAG_REGEX.test(name);\n        var isIgnored = ignore.indexOf(name) !== -1;\n\n        if (!isPascalCase && !isCompatTag && !isAllowedAllCaps && !isIgnored) {\n          context.report({\n            node: node,\n            message: 'Imported JSX component ' + name + ' must be in PascalCase'\n          });\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js":"/**\n * @fileoverview Prevents usage of Function.prototype.bind and arrow functions\n *               in React component definition.\n * @author Daniel Lo Nigro <dan.cx>\n */\n'use strict';\n\nvar Components = require('../util/Components');\nvar propName = require('jsx-ast-utils/propName');\n\n// -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevents usage of Function.prototype.bind and arrow functions in React component definition',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowArrowFunctions: {\n          default: false,\n          type: 'boolean'\n        },\n        allowBind: {\n          default: false,\n          type: 'boolean'\n        },\n        ignoreRefs: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n    var configuration = context.options[0] || {};\n\n    return {\n      CallExpression: function(node) {\n        var callee = node.callee;\n        if (\n          !configuration.allowBind &&\n          (callee.type !== 'MemberExpression' || callee.property.name !== 'bind')\n        ) {\n          return;\n        }\n        var ancestors = context.getAncestors(callee).reverse();\n        for (var i = 0, j = ancestors.length; i < j; i++) {\n          if (\n            !configuration.allowBind &&\n            (ancestors[i].type === 'MethodDefinition' && ancestors[i].key.name === 'render') ||\n            (ancestors[i].type === 'Property' && ancestors[i].key.name === 'render')\n          ) {\n            if (utils.isReturningJSX(ancestors[i])) {\n              context.report({\n                node: callee,\n                message: 'JSX props should not use .bind()'\n              });\n            }\n            break;\n          }\n        }\n      },\n\n      JSXAttribute: function(node) {\n        var isRef = configuration.ignoreRefs && propName(node) === 'ref';\n        if (isRef || !node.value || !node.value.expression) {\n          return;\n        }\n        var valueNode = node.value.expression;\n        if (\n          !configuration.allowBind &&\n          valueNode.type === 'CallExpression' &&\n          valueNode.callee.type === 'MemberExpression' &&\n          valueNode.callee.property.name === 'bind'\n        ) {\n          context.report({\n            node: node,\n            message: 'JSX props should not use .bind()'\n          });\n        } else if (\n          !configuration.allowArrowFunctions &&\n          valueNode.type === 'ArrowFunctionExpression'\n        ) {\n          context.report({\n            node: node,\n            message: 'JSX props should not use arrow functions'\n          });\n        } else if (\n          !configuration.allowBind &&\n          valueNode.type === 'BindExpression'\n        ) {\n          context.report({\n            node: node,\n            message: 'JSX props should not use ::'\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js":"/**\n * @fileoverview Disallow undeclared variables in JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\n/**\n * Checks if a node name match the JSX tag convention.\n * @param {String} name - Name of the node to check.\n * @returns {boolean} Whether or not the node name match the JSX tag convention.\n */\nvar tagConvention = /^[a-z]|\\-/;\nfunction isTagName(name) {\n  return tagConvention.test(name);\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow undeclared variables in JSX',\n      category: 'Possible Errors',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    /**\n     * Compare an identifier with the variables declared in the scope\n     * @param {ASTNode} node - Identifier or JSXIdentifier node\n     * @returns {void}\n     */\n    function checkIdentifierInJSX(node) {\n      var scope = context.getScope();\n      var variables = scope.variables;\n      var i;\n      var len;\n\n      // Ignore 'this' keyword (also maked as JSXIdentifier when used in JSX)\n      if (node.name === 'this') {\n        return;\n      }\n\n      while (scope.type !== 'global') {\n        scope = scope.upper;\n        variables = scope.variables.concat(variables);\n      }\n      if (scope.childScopes.length) {\n        variables = scope.childScopes[0].variables.concat(variables);\n        // Temporary fix for babel-eslint\n        if (scope.childScopes[0].childScopes.length) {\n          variables = scope.childScopes[0].childScopes[0].variables.concat(variables);\n        }\n      }\n\n      for (i = 0, len = variables.length; i < len; i++) {\n        if (variables[i].name === node.name) {\n          return;\n        }\n      }\n\n      context.report({\n        node: node,\n        message: '\\'' + node.name + '\\' is not defined.'\n      });\n    }\n\n    return {\n      JSXOpeningElement: function(node) {\n        switch (node.name.type) {\n          case 'JSXIdentifier':\n            node = node.name;\n            if (isTagName(node.name)) {\n              return;\n            }\n            break;\n          case 'JSXMemberExpression':\n            node = node.name;\n            do {\n              node = node.object;\n            } while (node && node.type !== 'JSXIdentifier');\n            break;\n          case 'JSXNamespacedName':\n            node = node.name.namespace;\n            break;\n          default:\n            break;\n        }\n        checkIdentifierInJSX(node);\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js":"/**\n * @fileoverview Prevent usage of unknown DOM property\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = {\n  ignore: []\n};\n\nvar UNKNOWN_MESSAGE = 'Unknown property \\'{{name}}\\' found, use \\'{{standardName}}\\' instead';\n\nvar DOM_ATTRIBUTE_NAMES = {\n  'accept-charset': 'acceptCharset',\n  class: 'className',\n  for: 'htmlFor',\n  'http-equiv': 'httpEquiv'\n};\n\nvar SVGDOM_ATTRIBUTE_NAMES = {\n  'accent-height': 'accentHeight',\n  'alignment-baseline': 'alignmentBaseline',\n  'arabic-form': 'arabicForm',\n  'baseline-shift': 'baselineShift',\n  'cap-height': 'capHeight',\n  'clip-path': 'clipPath',\n  'clip-rule': 'clipRule',\n  'color-interpolation': 'colorInterpolation',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  'color-profile': 'colorProfile',\n  'color-rendering': 'colorRendering',\n  'dominant-baseline': 'dominantBaseline',\n  'enable-background': 'enableBackground',\n  'fill-opacity': 'fillOpacity',\n  'fill-rule': 'fillRule',\n  'flood-color': 'floodColor',\n  'flood-opacity': 'floodOpacity',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-size-adjust': 'fontSizeAdjust',\n  'font-stretch': 'fontStretch',\n  'font-style': 'fontStyle',\n  'font-variant': 'fontVariant',\n  'font-weight': 'fontWeight',\n  'glyph-name': 'glyphName',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  'horiz-adv-x': 'horizAdvX',\n  'horiz-origin-x': 'horizOriginX',\n  'image-rendering': 'imageRendering',\n  'letter-spacing': 'letterSpacing',\n  'lighting-color': 'lightingColor',\n  'marker-end': 'markerEnd',\n  'marker-mid': 'markerMid',\n  'marker-start': 'markerStart',\n  'overline-position': 'overlinePosition',\n  'overline-thickness': 'overlineThickness',\n  'paint-order': 'paintOrder',\n  'panose-1': 'panose1',\n  'pointer-events': 'pointerEvents',\n  'rendering-intent': 'renderingIntent',\n  'shape-rendering': 'shapeRendering',\n  'stop-color': 'stopColor',\n  'stop-opacity': 'stopOpacity',\n  'strikethrough-position': 'strikethroughPosition',\n  'strikethrough-thickness': 'strikethroughThickness',\n  'stroke-dasharray': 'strokeDasharray',\n  'stroke-dashoffset': 'strokeDashoffset',\n  'stroke-linecap': 'strokeLinecap',\n  'stroke-linejoin': 'strokeLinejoin',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-width': 'strokeWidth',\n  'text-anchor': 'textAnchor',\n  'text-decoration': 'textDecoration',\n  'text-rendering': 'textRendering',\n  'underline-position': 'underlinePosition',\n  'underline-thickness': 'underlineThickness',\n  'unicode-bidi': 'unicodeBidi',\n  'unicode-range': 'unicodeRange',\n  'units-per-em': 'unitsPerEm',\n  'v-alphabetic': 'vAlphabetic',\n  'v-hanging': 'vHanging',\n  'v-ideographic': 'vIdeographic',\n  'v-mathematical': 'vMathematical',\n  'vector-effect': 'vectorEffect',\n  'vert-adv-y': 'vertAdvY',\n  'vert-origin-x': 'vertOriginX',\n  'vert-origin-y': 'vertOriginY',\n  'word-spacing': 'wordSpacing',\n  'writing-mode': 'writingMode',\n  'x-height': 'xHeight',\n  'xlink:actuate': 'xlinkActuate',\n  'xlink:arcrole': 'xlinkArcrole',\n  'xlink:href': 'xlinkHref',\n  'xlink:role': 'xlinkRole',\n  'xlink:show': 'xlinkShow',\n  'xlink:title': 'xlinkTitle',\n  'xlink:type': 'xlinkType',\n  'xml:base': 'xmlBase',\n  'xml:lang': 'xmlLang',\n  'xml:space': 'xmlSpace'\n};\n\nvar DOM_PROPERTY_NAMES = [\n  // Standard\n  'acceptCharset', 'accessKey', 'allowFullScreen', 'allowTransparency', 'autoComplete', 'autoFocus', 'autoPlay',\n  'cellPadding', 'cellSpacing', 'charSet', 'classID', 'className', 'colSpan', 'contentEditable', 'contextMenu',\n  'crossOrigin', 'dateTime', 'encType', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget',\n  'frameBorder', 'hrefLang', 'htmlFor', 'httpEquiv', 'inputMode', 'keyParams', 'keyType', 'marginHeight', 'marginWidth',\n  'maxLength', 'mediaGroup', 'minLength', 'noValidate', 'onAnimationEnd', 'onAnimationIteration', 'onAnimationStart',\n  'onBlur', 'onChange', 'onClick', 'onContextMenu', 'onCopy', 'onCompositionEnd', 'onCompositionStart',\n  'onCompositionUpdate', 'onCut', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave',\n  'onError', 'onFocus', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onLoad', 'onWheel', 'onDragOver',\n  'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver',\n  'onMouseUp', 'onPaste', 'onScroll', 'onSelect', 'onSubmit', 'onTransitionEnd', 'radioGroup', 'readOnly', 'rowSpan',\n  'spellCheck', 'srcDoc', 'srcLang', 'srcSet', 'tabIndex', 'useMap',\n  // Non standard\n  'autoCapitalize', 'autoCorrect',\n  'autoSave',\n  'itemProp', 'itemScope', 'itemType', 'itemRef', 'itemID'\n];\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n/**\n * Checks if a node matches the JSX tag convention.\n * @param {Object} node - JSX element being tested.\n * @returns {boolean} Whether or not the node name match the JSX tag convention.\n */\nvar tagConvention = /^[a-z][^-]*$/;\nfunction isTagName(node) {\n  if (tagConvention.test(node.parent.name.name)) {\n    // http://www.w3.org/TR/custom-elements/#type-extension-semantics\n    return !node.parent.attributes.some(function(attrNode) {\n      return (\n        attrNode.type === 'JSXAttribute' &&\n        attrNode.name.type === 'JSXIdentifier' &&\n        attrNode.name.name === 'is'\n      );\n    });\n  }\n  return false;\n}\n\n/**\n * Get the standard name of the attribute.\n * @param {String} name - Name of the attribute.\n * @returns {String} The standard name of the attribute.\n */\nfunction getStandardName(name) {\n  if (DOM_ATTRIBUTE_NAMES[name]) {\n    return DOM_ATTRIBUTE_NAMES[name];\n  }\n  if (SVGDOM_ATTRIBUTE_NAMES[name]) {\n    return SVGDOM_ATTRIBUTE_NAMES[name];\n  }\n  var i;\n  var found = DOM_PROPERTY_NAMES.some(function(element, index) {\n    i = index;\n    return element.toLowerCase() === name;\n  });\n  return found ? DOM_PROPERTY_NAMES[i] : null;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of unknown DOM property',\n      category: 'Possible Errors',\n      recommended: true\n    },\n    fixable: 'code',\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    function getIgnoreConfig() {\n      return context.options[0] && context.options[0].ignore || DEFAULTS.ignore;\n    }\n\n    var sourceCode = context.getSourceCode();\n\n    return {\n\n      JSXAttribute: function(node) {\n        var ignoreNames = getIgnoreConfig();\n        var name = sourceCode.getText(node.name);\n        var standardName = getStandardName(name);\n        if (!isTagName(node) || !standardName || ignoreNames.indexOf(name) >= 0) {\n          return;\n        }\n        context.report({\n          node: node,\n          message: UNKNOWN_MESSAGE,\n          data: {\n            name: name,\n            standardName: standardName\n          },\n          fix: function(fixer) {\n            return fixer.replaceText(node.name, standardName);\n          }\n        });\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js":"/**\n * @fileoverview Enforce or disallow spaces inside of curly braces in JSX attributes.\n * @author Jamund Ferguson\n * @author Brandyn Bennett\n * @author Michael Ficarra\n * @author Vignesh Anand\n * @author Jamund Ferguson\n * @author Yannick Croissant\n * @author Erik Wendel\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nvar SPACING = {\n  always: 'always',\n  never: 'never'\n};\nvar SPACING_VALUES = [SPACING.always, SPACING.never];\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      enum: SPACING_VALUES\n    }, {\n      type: 'object',\n      properties: {\n        allowMultiline: {\n          type: 'boolean'\n        },\n        spacing: {\n          type: 'object',\n          properties: {\n            objectLiterals: {\n              enum: SPACING_VALUES\n            }\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var sourceCode = context.getSourceCode();\n    var spaced = context.options[0] === SPACING.always;\n    var multiline = context.options[1] ? context.options[1].allowMultiline : true;\n    var spacing = context.options[1] ? context.options[1].spacing || {} : {};\n    var defaultSpacing = spaced ? SPACING.always : SPACING.never;\n    var objectLiteralSpacing = spacing.objectLiterals || (spaced ? SPACING.always : SPACING.never);\n\n    // --------------------------------------------------------------------------\n    // Helpers\n    // --------------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens have a newline between them.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not there is a newline between the tokens.\n     */\n    function isMultiline(left, right) {\n      return left.loc.start.line !== right.loc.start.line;\n    }\n\n    /**\n    * Reports that there shouldn't be a newline after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoBeginningNewline(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'There should be no newline after \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          var nextToken = sourceCode.getTokenAfter(token);\n          return fixer.replaceTextRange([token.range[1], nextToken.range[0]], spaced ? ' ' : '');\n        }\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a newline before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoEndingNewline(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'There should be no newline before \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          var previousToken = sourceCode.getTokenBefore(token);\n          return fixer.replaceTextRange([previousToken.range[1], token.range[0]], spaced ? ' ' : '');\n        }\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoBeginningSpace(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'There should be no space after \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          var nextToken = sourceCode.getTokenAfter(token);\n          var leadingComments = sourceCode.getNodeByRangeIndex(nextToken.range[0]).leadingComments;\n          var rangeEndRef = leadingComments ? leadingComments[0] : nextToken;\n          return fixer.removeRange([token.range[1], rangeEndRef.range[0]]);\n        }\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoEndingSpace(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'There should be no space before \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          var previousToken = sourceCode.getTokenBefore(token);\n          var trailingComments = sourceCode.getNodeByRangeIndex(previousToken.range[0]).trailingComments;\n          var rangeStartRef = trailingComments ? trailingComments[trailingComments.length - 1] : previousToken;\n          return fixer.removeRange([rangeStartRef.range[1], token.range[0]]);\n        }\n      });\n    }\n\n    /**\n    * Reports that there should be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredBeginningSpace(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'A space is required after \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          return fixer.insertTextAfter(token, ' ');\n        }\n      });\n    }\n\n    /**\n    * Reports that there should be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredEndingSpace(node, token) {\n      context.report({\n        node: node,\n        loc: token.loc.start,\n        message: 'A space is required before \\'' + token.value + '\\'',\n        fix: function(fixer) {\n          return fixer.insertTextBefore(token, ' ');\n        }\n      });\n    }\n\n    /**\n     * Determines if spacing in curly braces is valid.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     */\n    function validateBraceSpacing(node) {\n      // Only validate attributes\n      if (node.parent.type === 'JSXElement') {\n        return;\n      }\n      var first = context.getFirstToken(node);\n      var last = sourceCode.getLastToken(node);\n      var second = context.getTokenAfter(first);\n      var penultimate = sourceCode.getTokenBefore(last);\n\n      var leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;\n      second = leadingComments ? leadingComments[0] : second;\n\n      var trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;\n      penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;\n\n      var isObjectLiteral = first.value === second.value;\n      if (isObjectLiteral) {\n        if (objectLiteralSpacing === SPACING.never) {\n          if (sourceCode.isSpaceBetweenTokens(first, second)) {\n            reportNoBeginningSpace(node, first);\n          } else if (!multiline && isMultiline(first, second)) {\n            reportNoBeginningNewline(node, first);\n          }\n          if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n            reportNoEndingSpace(node, last);\n          } else if (!multiline && isMultiline(penultimate, last)) {\n            reportNoEndingNewline(node, last);\n          }\n        } else if (objectLiteralSpacing === SPACING.always) {\n          if (!sourceCode.isSpaceBetweenTokens(first, second)) {\n            reportRequiredBeginningSpace(node, first);\n          } else if (!multiline && isMultiline(first, second)) {\n            reportNoBeginningNewline(node, first);\n          }\n          if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n            reportRequiredEndingSpace(node, last);\n          } else if (!multiline && isMultiline(penultimate, last)) {\n            reportNoEndingNewline(node, last);\n          }\n        }\n      } else if (defaultSpacing === SPACING.always) {\n        if (!sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportRequiredBeginningSpace(node, first);\n        } else if (!multiline && isMultiline(first, second)) {\n          reportNoBeginningNewline(node, first);\n        }\n\n        if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportRequiredEndingSpace(node, last);\n        } else if (!multiline && isMultiline(penultimate, last)) {\n          reportNoEndingNewline(node, last);\n        }\n      } else if (defaultSpacing === SPACING.never) {\n        if (isMultiline(first, second)) {\n          if (!multiline) {\n            reportNoBeginningNewline(node, first);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportNoBeginningSpace(node, first);\n        }\n        if (isMultiline(penultimate, last)) {\n          if (!multiline) {\n            reportNoEndingNewline(node, last);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXExpressionContainer: validateBraceSpacing,\n      JSXSpreadAttribute: validateBraceSpacing\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js":"/**\n * @fileoverview Disallow or enforce spaces around equal signs in JSX attributes.\n * @author ryym\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow or enforce spaces around equal signs in JSX attributes',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      enum: ['always', 'never']\n    }]\n  },\n\n  create: function(context) {\n    var config = context.options[0];\n    var sourceCode = context.getSourceCode();\n\n    /**\n     * Determines a given attribute node has an equal sign.\n     * @param {ASTNode} attrNode - The attribute node.\n     * @returns {boolean} Whether or not the attriute node has an equal sign.\n     */\n    function hasEqual(attrNode) {\n      return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXOpeningElement: function(node) {\n        node.attributes.forEach(function(attrNode) {\n          if (!hasEqual(attrNode)) {\n            return;\n          }\n\n          var equalToken = sourceCode.getTokenAfter(attrNode.name);\n          var spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);\n          var spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);\n\n          switch (config) {\n            default:\n            case 'never':\n              if (spacedBefore) {\n                context.report({\n                  node: attrNode,\n                  loc: equalToken.loc.start,\n                  message: 'There should be no space before \\'=\\'',\n                  fix: function(fixer) {\n                    return fixer.removeRange([attrNode.name.range[1], equalToken.start]);\n                  }\n                });\n              }\n              if (spacedAfter) {\n                context.report({\n                  node: attrNode,\n                  loc: equalToken.loc.start,\n                  message: 'There should be no space after \\'=\\'',\n                  fix: function(fixer) {\n                    return fixer.removeRange([equalToken.end, attrNode.value.range[0]]);\n                  }\n                });\n              }\n              break;\n            case 'always':\n              if (!spacedBefore) {\n                context.report({\n                  node: attrNode,\n                  loc: equalToken.loc.start,\n                  message: 'A space is required before \\'=\\'',\n                  fix: function(fixer) {\n                    return fixer.insertTextBefore(equalToken, ' ');\n                  }\n                });\n              }\n              if (!spacedAfter) {\n                context.report({\n                  node: attrNode,\n                  loc: equalToken.loc.start,\n                  message: 'A space is required after \\'=\\'',\n                  fix: function(fixer) {\n                    return fixer.insertTextAfter(equalToken, ' ');\n                  }\n                });\n              }\n              break;\n          }\n        });\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js":"/**\n * @fileoverview Enforce props alphabetical sorting\n * @author Ilya Volodin, Yannick Croissant\n */\n'use strict';\n\nvar propName = require('jsx-ast-utils/propName');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isCallbackPropName(name) {\n  return /^on[A-Z]/.test(name);\n}\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce props alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        // Whether callbacks (prefixed with \"on\") should be listed at the very end,\n        // after all other props. Supersedes shorthandLast.\n        callbacksLast: {\n          type: 'boolean'\n        },\n        // Whether shorthand properties (without a value) should be listed first\n        shorthandFirst: {\n          type: 'boolean'\n        },\n        // Whether shorthand properties (without a value) should be listed last\n        shorthandLast: {\n          type: 'boolean'\n        },\n        ignoreCase: {\n          type: 'boolean'\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var configuration = context.options[0] || {};\n    var ignoreCase = configuration.ignoreCase || false;\n    var callbacksLast = configuration.callbacksLast || false;\n    var shorthandFirst = configuration.shorthandFirst || false;\n    var shorthandLast = configuration.shorthandLast || false;\n    var noSortAlphabetically = configuration.noSortAlphabetically || false;\n\n    return {\n      JSXOpeningElement: function(node) {\n        node.attributes.reduce(function(memo, decl, idx, attrs) {\n          if (decl.type === 'JSXSpreadAttribute') {\n            return attrs[idx + 1];\n          }\n\n          var previousPropName = propName(memo);\n          var currentPropName = propName(decl);\n          var previousValue = memo.value;\n          var currentValue = decl.value;\n          var previousIsCallback = isCallbackPropName(previousPropName);\n          var currentIsCallback = isCallbackPropName(currentPropName);\n\n          if (ignoreCase) {\n            previousPropName = previousPropName.toLowerCase();\n            currentPropName = currentPropName.toLowerCase();\n          }\n\n          if (callbacksLast) {\n            if (!previousIsCallback && currentIsCallback) {\n              // Entering the callback prop section\n              return decl;\n            }\n            if (previousIsCallback && !currentIsCallback) {\n              // Encountered a non-callback prop after a callback prop\n              context.report({\n                node: memo,\n                message: 'Callbacks must be listed after all other props'\n              });\n              return memo;\n            }\n          }\n\n          if (shorthandFirst) {\n            if (currentValue && !previousValue) {\n              return decl;\n            }\n            if (!currentValue && previousValue) {\n              context.report({\n                node: memo,\n                message: 'Shorthand props must be listed before all other props'\n              });\n              return memo;\n            }\n          }\n\n          if (shorthandLast) {\n            if (!currentValue && previousValue) {\n              return decl;\n            }\n            if (currentValue && !previousValue) {\n              context.report({\n                node: memo,\n                message: 'Shorthand props must be listed after all other props'\n              });\n              return memo;\n            }\n          }\n\n          if (!noSortAlphabetically && currentPropName < previousPropName) {\n            context.report({\n              node: decl,\n              message: 'Props should be sorted alphabetically'\n            });\n            return memo;\n          }\n\n          return decl;\n        }, node.attributes[0]);\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/sort-prop-types.js":"/**\n * @fileoverview Enforce propTypes declarations alphabetical sorting\n */\n'use strict';\n\nvar find = require('array.prototype.find');\n\nvar variableUtil = require('../util/variable');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce propTypes declarations alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        requiredFirst: {\n          type: 'boolean'\n        },\n        callbacksLast: {\n          type: 'boolean'\n        },\n        ignoreCase: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    var sourceCode = context.getSourceCode();\n    var configuration = context.options[0] || {};\n    var requiredFirst = configuration.requiredFirst || false;\n    var callbacksLast = configuration.callbacksLast || false;\n    var ignoreCase = configuration.ignoreCase || false;\n\n    /**\n     * Checks if node is `propTypes` declaration\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is `propTypes` declaration, false if not.\n     */\n    function isPropTypesDeclaration(node) {\n\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return (tokens[0] && tokens[0].value === 'propTypes') ||\n               (tokens[1] && tokens[1].value === 'propTypes');\n      }\n\n      return Boolean(\n        node &&\n        node.name === 'propTypes'\n      );\n    }\n\n    function getKey(node) {\n      return sourceCode.getText(node.key || node.argument);\n    }\n\n    function getValueName(node) {\n      return node.type === 'Property' && node.value.property && node.value.property.name;\n    }\n\n    function isCallbackPropName(propName) {\n      return /^on[A-Z]/.test(propName);\n    }\n\n    function isRequiredProp(node) {\n      return getValueName(node) === 'isRequired';\n    }\n\n    /**\n     * Checks if propTypes declarations are sorted\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n    function checkSorted(declarations) {\n      declarations.reduce(function(prev, curr, idx, decls) {\n        if (/SpreadProperty$/.test(curr.type)) {\n          return decls[idx + 1];\n        }\n\n        var prevPropName = getKey(prev);\n        var currentPropName = getKey(curr);\n        var previousIsRequired = isRequiredProp(prev);\n        var currentIsRequired = isRequiredProp(curr);\n        var previousIsCallback = isCallbackPropName(prevPropName);\n        var currentIsCallback = isCallbackPropName(currentPropName);\n\n        if (ignoreCase) {\n          prevPropName = prevPropName.toLowerCase();\n          currentPropName = currentPropName.toLowerCase();\n        }\n\n        if (requiredFirst) {\n          if (previousIsRequired && !currentIsRequired) {\n            // Transition between required and non-required. Don't compare for alphabetical.\n            return curr;\n          }\n          if (!previousIsRequired && currentIsRequired) {\n            // Encountered a non-required prop after a required prop\n            context.report({\n              node: curr,\n              message: 'Required prop types must be listed before all other prop types'\n            });\n            return curr;\n          }\n        }\n\n        if (callbacksLast) {\n          if (!previousIsCallback && currentIsCallback) {\n            // Entering the callback prop section\n            return curr;\n          }\n          if (previousIsCallback && !currentIsCallback) {\n            // Encountered a non-callback prop after a callback prop\n            context.report({\n              node: prev,\n              message: 'Callback prop types must be listed after all other prop types'\n            });\n            return prev;\n          }\n        }\n\n        if (currentPropName < prevPropName) {\n          context.report({\n            node: curr,\n            message: 'Prop types declarations should be sorted alphabetically'\n          });\n          return prev;\n        }\n\n        return curr;\n      }, declarations[0]);\n    }\n\n    return {\n      ClassProperty: function(node) {\n        if (isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {\n          checkSorted(node.value.properties);\n        }\n      },\n\n      MemberExpression: function(node) {\n        if (!isPropTypesDeclaration(node.property)) {\n          return;\n        }\n        var right = node.parent.right;\n        var declarations;\n        switch (right && right.type) {\n          case 'ObjectExpression':\n            declarations = right.properties;\n            break;\n          case 'Identifier':\n            var variable = find(variableUtil.variablesInScope(context), function (item) {\n              return item.name === right.name;\n            });\n            if (\n              !variable || !variable.defs[0] ||\n              !variable.defs[0].node.init || !variable.defs[0].node.init.properties\n            ) {\n              break;\n            }\n            declarations = variable.defs[0].node.init.properties;\n            break;\n          default:\n            break;\n        }\n        if (declarations) {\n          checkSorted(declarations);\n        }\n      },\n\n      ObjectExpression: function(node) {\n        node.properties.forEach(function(property) {\n          if (!property.key) {\n            return;\n          }\n\n          if (!isPropTypesDeclaration(property.key)) {\n            return;\n          }\n          if (property.value.type === 'ObjectExpression') {\n            checkSorted(property.value.properties);\n          }\n        });\n      }\n\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js":"/**\n * @fileoverview Enforce boolean attributes notation in JSX\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce boolean attributes notation in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      enum: ['always', 'never']\n    }]\n  },\n\n  create: function(context) {\n\n    var configuration = context.options[0] || 'never';\n\n    var NEVER_MESSAGE = 'Value must be omitted for boolean attributes';\n    var ALWAYS_MESSAGE = 'Value must be set for boolean attributes';\n\n    return {\n      JSXAttribute: function(node) {\n        switch (configuration) {\n          case 'always':\n            if (node.value === null) {\n              context.report({\n                node: node,\n                message: ALWAYS_MESSAGE,\n                fix: function(fixer) {\n                  return fixer.insertTextAfter(node, '={true}');\n                }\n              });\n            }\n            break;\n          case 'never':\n            if (node.value && node.value.type === 'JSXExpressionContainer' && node.value.expression.value === true) {\n              context.report({\n                node: node,\n                message: NEVER_MESSAGE,\n                fix: function(fixer) {\n                  return fixer.removeRange([node.name.range[1], node.value.range[1]]);\n                }\n              });\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/sort-comp.js":"/**\n * @fileoverview Enforce component methods order\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\nvar util = require('util');\n\nvar Components = require('../util/Components');\n\n/**\n * Get the methods order from the default config and the user config\n * @param {Object} defaultConfig The default configuration.\n * @param {Object} userConfig The user configuration.\n * @returns {Array} Methods order\n */\nfunction getMethodsOrder(defaultConfig, userConfig) {\n  userConfig = userConfig || {};\n\n  var groups = util._extend(defaultConfig.groups, userConfig.groups);\n  var order = userConfig.order || defaultConfig.order;\n\n  var config = [];\n  var entry;\n  for (var i = 0, j = order.length; i < j; i++) {\n    entry = order[i];\n    if (has(groups, entry)) {\n      config = config.concat(groups[entry]);\n    } else {\n      config.push(entry);\n    }\n  }\n\n  return config;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce component methods order',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        order: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        groups: {\n          type: 'object',\n          patternProperties: {\n            '^.*$': {\n              type: 'array',\n              items: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components) {\n\n    var errors = {};\n\n    var MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';\n\n    var methodsOrder = getMethodsOrder({\n      order: [\n        'static-methods',\n        'lifecycle',\n        'everything-else',\n        'render'\n      ],\n      groups: {\n        lifecycle: [\n          'displayName',\n          'propTypes',\n          'contextTypes',\n          'childContextTypes',\n          'mixins',\n          'statics',\n          'defaultProps',\n          'constructor',\n          'getDefaultProps',\n          'state',\n          'getInitialState',\n          'getChildContext',\n          'componentWillMount',\n          'componentDidMount',\n          'componentWillReceiveProps',\n          'shouldComponentUpdate',\n          'componentWillUpdate',\n          'componentDidUpdate',\n          'componentWillUnmount'\n        ]\n      }\n    }, context.options[0]);\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    var regExpRegExp = /\\/(.*)\\/([g|y|i|m]*)/;\n\n    /**\n     * Get indexes of the matching patterns in methods order configuration\n     * @param {Object} method - Method metadata.\n     * @returns {Array} The matching patterns indexes. Return [Infinity] if there is no match.\n     */\n    function getRefPropIndexes(method) {\n      var isRegExp;\n      var matching;\n      var i;\n      var j;\n      var indexes = [];\n\n      if (method.static) {\n        for (i = 0, j = methodsOrder.length; i < j; i++) {\n          if (methodsOrder[i] === 'static-methods') {\n            indexes.push(i);\n            break;\n          }\n        }\n      }\n\n      if (method.typeAnnotation) {\n        for (i = 0, j = methodsOrder.length; i < j; i++) {\n          if (methodsOrder[i] === 'type-annotations') {\n            indexes.push(i);\n            break;\n          }\n        }\n      }\n\n      // Either this is not a static method or static methods are not specified\n      // in the methodsOrder.\n      if (indexes.length === 0) {\n        for (i = 0, j = methodsOrder.length; i < j; i++) {\n          isRegExp = methodsOrder[i].match(regExpRegExp);\n          if (isRegExp) {\n            matching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);\n          } else {\n            matching = methodsOrder[i] === method.name;\n          }\n          if (matching) {\n            indexes.push(i);\n          }\n        }\n      }\n\n      // No matching pattern, return 'everything-else' index\n      if (indexes.length === 0) {\n        for (i = 0, j = methodsOrder.length; i < j; i++) {\n          if (methodsOrder[i] === 'everything-else') {\n            indexes.push(i);\n            break;\n          }\n        }\n      }\n\n      // No matching pattern and no 'everything-else' group\n      if (indexes.length === 0) {\n        indexes.push(Infinity);\n      }\n\n      return indexes;\n    }\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n    function getPropertyName(node) {\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;\n      }\n\n      return node.key.name;\n    }\n\n    /**\n     * Store a new error in the error list\n     * @param {Object} propA - Mispositioned property.\n     * @param {Object} propB - Reference property.\n     */\n    function storeError(propA, propB) {\n      // Initialize the error object if needed\n      if (!errors[propA.index]) {\n        errors[propA.index] = {\n          node: propA.node,\n          score: 0,\n          closest: {\n            distance: Infinity,\n            ref: {\n              node: null,\n              index: 0\n            }\n          }\n        };\n      }\n      // Increment the prop score\n      errors[propA.index].score++;\n      // Stop here if we already have pushed another node at this position\n      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {\n        return;\n      }\n      // Stop here if we already have a closer reference\n      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {\n        return;\n      }\n      // Update the closest reference\n      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);\n      errors[propA.index].closest.ref.node = propB.node;\n      errors[propA.index].closest.ref.index = propB.index;\n    }\n\n    /**\n     * Dedupe errors, only keep the ones with the highest score and delete the others\n     */\n    function dedupeErrors() {\n      for (var i in errors) {\n        if (!has(errors, i)) {\n          continue;\n        }\n        var index = errors[i].closest.ref.index;\n        if (!errors[index]) {\n          continue;\n        }\n        if (errors[i].score > errors[index].score) {\n          delete errors[index];\n        } else {\n          delete errors[i];\n        }\n      }\n    }\n\n    /**\n     * Report errors\n     */\n    function reportErrors() {\n      dedupeErrors();\n\n      var nodeA;\n      var nodeB;\n      var indexA;\n      var indexB;\n      for (var i in errors) {\n        if (!has(errors, i)) {\n          continue;\n        }\n\n        nodeA = errors[i].node;\n        nodeB = errors[i].closest.ref.node;\n        indexA = i;\n        indexB = errors[i].closest.ref.index;\n\n        context.report({\n          node: nodeA,\n          message: MISPOSITION_MESSAGE,\n          data: {\n            propA: getPropertyName(nodeA),\n            propB: getPropertyName(nodeB),\n            position: indexA < indexB ? 'before' : 'after'\n          }\n        });\n      }\n    }\n\n    /**\n     * Get properties for a given AST node\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Array} Properties array.\n     */\n    function getComponentProperties(node) {\n      switch (node.type) {\n        case 'ClassDeclaration':\n          return node.body.body;\n        case 'ObjectExpression':\n          return node.properties.filter(function(property) {\n            return property.type === 'Property';\n          });\n        default:\n          return [];\n      }\n    }\n\n    /**\n     * Compare two properties and find out if they are in the right order\n     * @param {Array} propertiesInfos Array containing all the properties metadata.\n     * @param {Object} propA First property name and metadata\n     * @param {Object} propB Second property name.\n     * @returns {Object} Object containing a correct true/false flag and the correct indexes for the two properties.\n     */\n    function comparePropsOrder(propertiesInfos, propA, propB) {\n      var i;\n      var j;\n      var k;\n      var l;\n      var refIndexA;\n      var refIndexB;\n\n      // Get references indexes (the correct position) for given properties\n      var refIndexesA = getRefPropIndexes(propA);\n      var refIndexesB = getRefPropIndexes(propB);\n\n      // Get current indexes for given properties\n      var classIndexA = propertiesInfos.indexOf(propA);\n      var classIndexB = propertiesInfos.indexOf(propB);\n\n      // Loop around the references indexes for the 1st property\n      for (i = 0, j = refIndexesA.length; i < j; i++) {\n        refIndexA = refIndexesA[i];\n\n        // Loop around the properties for the 2nd property (for comparison)\n        for (k = 0, l = refIndexesB.length; k < l; k++) {\n          refIndexB = refIndexesB[k];\n\n          if (\n            // Comparing the same properties\n            refIndexA === refIndexB ||\n            // 1st property is placed before the 2nd one in reference and in current component\n            refIndexA < refIndexB && classIndexA < classIndexB ||\n            // 1st property is placed after the 2nd one in reference and in current component\n            refIndexA > refIndexB && classIndexA > classIndexB\n          ) {\n            return {\n              correct: true,\n              indexA: classIndexA,\n              indexB: classIndexB\n            };\n          }\n\n        }\n      }\n\n      // We did not find any correct match between reference and current component\n      return {\n        correct: false,\n        indexA: refIndexA,\n        indexB: refIndexB\n      };\n    }\n\n    /**\n     * Check properties order from a properties list and store the eventual errors\n     * @param {Array} properties Array containing all the properties.\n     */\n    function checkPropsOrder(properties) {\n      var propertiesInfos = properties.map(function(node) {\n        return {\n          name: getPropertyName(node),\n          static: node.static,\n          typeAnnotation: !!node.typeAnnotation && node.value === null\n        };\n      });\n\n      var i;\n      var j;\n      var k;\n      var l;\n      var propA;\n      var propB;\n      var order;\n\n      // Loop around the properties\n      for (i = 0, j = propertiesInfos.length; i < j; i++) {\n        propA = propertiesInfos[i];\n\n        // Loop around the properties a second time (for comparison)\n        for (k = 0, l = propertiesInfos.length; k < l; k++) {\n          propB = propertiesInfos[k];\n\n          // Compare the properties order\n          order = comparePropsOrder(propertiesInfos, propA, propB);\n\n          // Continue to next comparison is order is correct\n          if (order.correct === true) {\n            continue;\n          }\n\n          // Store an error if the order is incorrect\n          storeError({\n            node: properties[i],\n            index: order.indexA\n          }, {\n            node: properties[k],\n            index: order.indexB\n          });\n        }\n      }\n\n    }\n\n    return {\n      'Program:exit': function() {\n        var list = components.list();\n        for (var component in list) {\n          if (!has(list, component)) {\n            continue;\n          }\n          var properties = getComponentProperties(list[component].node);\n          checkPropsOrder(properties);\n        }\n\n        reportErrors();\n      }\n    };\n\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js":"/**\n * @fileoverview Enforce no duplicate props\n * @author Markus Ånöstam\n */\n\n'use strict';\n\nvar has = require('has');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce no duplicate props',\n      category: 'Possible Errors',\n      recommended: true\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreCase: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function (context) {\n\n    var configuration = context.options[0] || {};\n    var ignoreCase = configuration.ignoreCase || false;\n\n    return {\n      JSXOpeningElement: function (node) {\n        var props = {};\n\n        node.attributes.forEach(function(decl) {\n          if (decl.type === 'JSXSpreadAttribute') {\n            return;\n          }\n\n          var name = decl.name.name;\n\n          if (ignoreCase) {\n            name = name.toLowerCase();\n          }\n\n          if (has(props, name)) {\n            context.report({\n              node: decl,\n              message: 'No duplicate props allowed'\n            });\n          } else {\n            props[name] = 1;\n          }\n        });\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js":"/**\n * @fileoverview Limit maximum of props on a single line in JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Limit maximum of props on a single line in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        maximum: {\n          type: 'integer',\n          minimum: 1\n        },\n        when: {\n          type: 'string',\n          enum: ['always', 'multiline']\n        }\n      }\n    }]\n  },\n\n  create: function (context) {\n\n    var sourceCode = context.getSourceCode();\n    var configuration = context.options[0] || {};\n    var maximum = configuration.maximum || 1;\n    var when = configuration.when || 'always';\n\n    function getPropName(propNode) {\n      if (propNode.type === 'JSXSpreadAttribute') {\n        return sourceCode.getText(propNode.argument);\n      }\n      return propNode.name.name;\n    }\n\n    return {\n      JSXOpeningElement: function (node) {\n        if (!node.attributes.length) {\n          return;\n        }\n\n        if (when === 'multiline' && node.loc.start.line === node.loc.end.line) {\n          return;\n        }\n\n        var firstProp = node.attributes[0];\n        var linePartitionedProps = [[firstProp]];\n\n        node.attributes.reduce(function(last, decl) {\n          if (last.loc.end.line === decl.loc.start.line) {\n            linePartitionedProps[linePartitionedProps.length - 1].push(decl);\n          } else {\n            linePartitionedProps.push([decl]);\n          }\n          return decl;\n        });\n\n        linePartitionedProps.forEach(function(propsInLine) {\n          if (propsInLine.length > maximum) {\n            var name = getPropName(propsInLine[maximum]);\n            context.report({\n              node: propsInLine[maximum],\n              message: 'Prop `' + name + '` must be placed on a new line'\n            });\n          }\n        });\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js":"/**\n * @fileoverview Prevent using string literals in React component definition\n * @author Caleb Morris\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent using string literals in React component definition',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {},\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    function reportLiteralNode(node) {\n      context.report({\n        node: node,\n        message: 'Missing JSX expression container around literal string'\n      });\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      Literal: function(node) {\n        if (\n         !/^[\\s]+$/.test(node.value) &&\n          node.parent &&\n          node.parent.type !== 'JSXExpressionContainer' &&\n          node.parent.type !== 'JSXAttribute' &&\n          node.parent.type.indexOf('JSX') !== -1\n        ) {\n          reportLiteralNode(node);\n        }\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js":"/**\n * @fileoverview Validate props indentation in JSX\n * @author Yannick Croissant\n\n * This rule has been ported and modified from eslint and nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @copyright 2015 Vitaly Puzrin. All rights reserved.\n * @copyright 2015 Gyandeep Singh. All rights reserved.\n Copyright (C) 2014 by Vitaly Puzrin\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the 'Software'), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Validate props indentation in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      oneOf: [{\n        enum: ['tab']\n      }, {\n        type: 'integer'\n      }]\n    }]\n  },\n\n  create: function(context) {\n\n    var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';\n\n    var extraColumnStart = 0;\n    var indentType = 'space';\n    var indentSize = 4;\n\n    var sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === 'tab') {\n        indentSize = 1;\n        indentType = 'tab';\n      } else if (typeof context.options[0] === 'number') {\n        indentSize = context.options[0];\n        indentType = 'space';\n      }\n    }\n\n    /**\n     * Reports a given indent violation and properly pluralizes the message\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {Number} needed Expected indentation character count\n     * @param {Number} gotten Indentation character count in the actual node/code\n     * @param {Object=} loc Error line and column location\n     */\n    function report(node, needed, gotten, loc) {\n      var msgContext = {\n        needed: needed,\n        type: indentType,\n        characters: needed === 1 ? 'character' : 'characters',\n        gotten: gotten\n      };\n\n      if (loc) {\n        context.report({\n          node: node,\n          loc: loc,\n          message: MESSAGE,\n          data: msgContext\n        });\n      } else {\n        context.report({\n          node: node,\n          message: MESSAGE,\n          data: msgContext,\n          fix: function(fixer) {\n            return fixer.replaceTextRange([node.start - node.loc.start.column, node.start],\n              Array(needed + 1).join(indentType === 'space' ? ' ' : '\\t'));\n          }\n        });\n      }\n    }\n\n    /**\n     * Get node indent\n     * @param {ASTNode} node Node to examine\n     * @param {Boolean} byLastLine get indent of node's last line\n     * @param {Boolean} excludeCommas skip comma on start of line\n     * @return {Number} Indent\n     */\n    function getNodeIndent(node, byLastLine, excludeCommas) {\n      byLastLine = byLastLine || false;\n      excludeCommas = excludeCommas || false;\n\n      var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);\n      var lines = src.split('\\n');\n      if (byLastLine) {\n        src = lines[lines.length - 1];\n      } else {\n        src = lines[0];\n      }\n\n      var skip = excludeCommas ? ',' : '';\n\n      var regExp;\n      if (indentType === 'space') {\n        regExp = new RegExp('^[ ' + skip + ']+');\n      } else {\n        regExp = new RegExp('^[\\t' + skip + ']+');\n      }\n\n      var indent = regExp.exec(src);\n      return indent ? indent[0].length : 0;\n    }\n\n    /**\n     * Checks node is the first in its own start line. By default it looks by start line.\n     * @param {ASTNode} node The node to check\n     * @param {Boolean} [byEndLocation] Lookup based on start position or end\n     * @return {Boolean} true if its the first in the its start line\n     */\n    function isNodeFirstInLine(node, byEndLocation) {\n      var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node);\n      var startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line;\n      var endLine = firstToken ? firstToken.loc.end.line : -1;\n\n      return startLine !== endLine;\n    }\n\n    /**\n     * Check indent for nodes list\n     * @param {ASTNode[]} nodes list of node objects\n     * @param {Number} indent needed indent\n     * @param {Boolean} excludeCommas skip comma on start of line\n     */\n    function checkNodesIndent(nodes, indent, excludeCommas) {\n      nodes.forEach(function(node) {\n        var nodeIndent = getNodeIndent(node, false, excludeCommas);\n        if (\n          node.type !== 'ArrayExpression' && node.type !== 'ObjectExpression' &&\n          nodeIndent !== indent && isNodeFirstInLine(node)\n        ) {\n          report(node, indent, nodeIndent);\n        }\n      });\n    }\n\n    return {\n      JSXOpeningElement: function(node) {\n        var elementIndent = getNodeIndent(node);\n        checkNodesIndent(node.attributes, elementIndent + indentSize);\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js":"/**\n * @fileoverview Validate JSX indentation\n * @author Yannick Croissant\n\n * This rule has been ported and modified from eslint and nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @copyright 2015 Vitaly Puzrin. All rights reserved.\n * @copyright 2015 Gyandeep Singh. All rights reserved.\n Copyright (C) 2014 by Vitaly Puzrin\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the 'Software'), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Validate JSX indentation',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'whitespace',\n    schema: [{\n      oneOf: [{\n        enum: ['tab']\n      }, {\n        type: 'integer'\n      }]\n    }]\n  },\n\n  create: function(context) {\n\n    var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';\n\n    var extraColumnStart = 0;\n    var indentType = 'space';\n    var indentSize = 4;\n\n    var sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === 'tab') {\n        indentSize = 1;\n        indentType = 'tab';\n      } else if (typeof context.options[0] === 'number') {\n        indentSize = context.options[0];\n        indentType = 'space';\n      }\n    }\n\n    var indentChar = indentType === 'space' ? ' ' : '\\t';\n\n    /**\n     * Responsible for fixing the indentation issue fix\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {Number} needed Expected indentation character count\n     * @returns {Function} function to be executed by the fixer\n     * @private\n     */\n    function getFixerFunction(node, needed) {\n      return function(fixer) {\n        var indent = Array(needed + 1).join(indentChar);\n        return fixer.replaceTextRange(\n          [node.start - node.loc.start.column, node.start],\n          indent\n        );\n      };\n    }\n\n    /**\n     * Reports a given indent violation and properly pluralizes the message\n     * @param {ASTNode} node Node violating the indent rule\n     * @param {Number} needed Expected indentation character count\n     * @param {Number} gotten Indentation character count in the actual node/code\n     * @param {Object} loc Error line and column location\n     */\n    function report(node, needed, gotten, loc) {\n      var msgContext = {\n        needed: needed,\n        type: indentType,\n        characters: needed === 1 ? 'character' : 'characters',\n        gotten: gotten\n      };\n\n      if (loc) {\n        context.report({\n          node: node,\n          loc: loc,\n          message: MESSAGE,\n          data: msgContext,\n          fix: getFixerFunction(node, needed)\n        });\n      } else {\n        context.report({\n          node: node,\n          message: MESSAGE,\n          data: msgContext,\n          fix: getFixerFunction(node, needed)\n        });\n      }\n    }\n\n    /**\n     * Get node indent\n     * @param {ASTNode} node Node to examine\n     * @param {Boolean} byLastLine get indent of node's last line\n     * @param {Boolean} excludeCommas skip comma on start of line\n     * @return {Number} Indent\n     */\n    function getNodeIndent(node, byLastLine, excludeCommas) {\n      byLastLine = byLastLine || false;\n      excludeCommas = excludeCommas || false;\n\n      var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);\n      var lines = src.split('\\n');\n      if (byLastLine) {\n        src = lines[lines.length - 1];\n      } else {\n        src = lines[0];\n      }\n\n      var skip = excludeCommas ? ',' : '';\n\n      var regExp;\n      if (indentType === 'space') {\n        regExp = new RegExp('^[ ' + skip + ']+');\n      } else {\n        regExp = new RegExp('^[\\t' + skip + ']+');\n      }\n\n      var indent = regExp.exec(src);\n      return indent ? indent[0].length : 0;\n    }\n\n    /**\n     * Checks node is the first in its own start line. By default it looks by start line.\n     * @param {ASTNode} node The node to check\n     * @return {Boolean} true if its the first in the its start line\n     */\n    function isNodeFirstInLine(node) {\n      var token = node;\n      do {\n        token = sourceCode.getTokenBefore(token);\n      } while (token.type === 'JSXText' && /^\\s*$/.test(token.value));\n      var startLine = node.loc.start.line;\n      var endLine = token ? token.loc.end.line : -1;\n\n      return startLine !== endLine;\n    }\n\n  /**\n   * Check if the node is the right member of a logical expression\n   * @param {ASTNode} node The node to check\n   * @return {Boolean} true if its the case, false if not\n   */\n    function isRightInLogicalExp(node) {\n      return (\n        node.parent &&\n        node.parent.parent &&\n        node.parent.parent.type === 'LogicalExpression' &&\n        node.parent.parent.right === node.parent\n      );\n    }\n\n  /**\n   * Check if the node is the alternate member of a conditional expression\n   * @param {ASTNode} node The node to check\n   * @return {Boolean} true if its the case, false if not\n   */\n    function isAlternateInConditionalExp(node) {\n      return (\n        node.parent &&\n        node.parent.parent &&\n        node.parent.parent.type === 'ConditionalExpression' &&\n        node.parent.parent.alternate === node.parent &&\n        sourceCode.getTokenBefore(node).value !== '('\n      );\n    }\n\n    /**\n     * Check indent for nodes list\n     * @param {ASTNode} node The node to check\n     * @param {Number} indent needed indent\n     * @param {Boolean} excludeCommas skip comma on start of line\n     */\n    function checkNodesIndent(node, indent, excludeCommas) {\n      var nodeIndent = getNodeIndent(node, false, excludeCommas);\n      var isCorrectRightInLogicalExp = isRightInLogicalExp(node) && (nodeIndent - indent) === indentSize;\n      var isCorrectAlternateInCondExp = isAlternateInConditionalExp(node) && (nodeIndent - indent) === 0;\n      if (\n        nodeIndent !== indent &&\n        isNodeFirstInLine(node) &&\n        !isCorrectRightInLogicalExp &&\n        !isCorrectAlternateInCondExp\n      ) {\n        report(node, indent, nodeIndent);\n      }\n    }\n\n    return {\n      JSXOpeningElement: function(node) {\n        var prevToken = sourceCode.getTokenBefore(node);\n        if (!prevToken) {\n          return;\n        }\n        // Use the parent in a list or an array\n        if (prevToken.type === 'JSXText' || prevToken.type === 'Punctuator' && prevToken.value === ',') {\n          prevToken = sourceCode.getNodeByRangeIndex(prevToken.start);\n          prevToken = prevToken.type === 'Literal' ? prevToken.parent : prevToken;\n        // Use the first non-punctuator token in a conditional expression\n        } else if (prevToken.type === 'Punctuator' && prevToken.value === ':') {\n          do {\n            prevToken = sourceCode.getTokenBefore(prevToken);\n          } while (prevToken.type === 'Punctuator');\n          prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);\n          while (prevToken.parent && prevToken.parent.type !== 'ConditionalExpression') {\n            prevToken = prevToken.parent;\n          }\n        }\n        prevToken = prevToken.type === 'JSXExpressionContainer' ? prevToken.expression : prevToken;\n\n        var parentElementIndent = getNodeIndent(prevToken);\n        var indent = (\n          prevToken.loc.start.line === node.loc.start.line ||\n          isRightInLogicalExp(node) ||\n          isAlternateInConditionalExp(node)\n        ) ? 0 : indentSize;\n        checkNodesIndent(node, parentElementIndent + indent);\n      },\n      JSXClosingElement: function(node) {\n        if (!node.parent) {\n          return;\n        }\n        var peerElementIndent = getNodeIndent(node.parent.openingElement);\n        checkNodesIndent(node, peerElementIndent);\n      },\n      JSXExpressionContainer: function(node) {\n        if (!node.parent) {\n          return;\n        }\n        var parentNodeIndent = getNodeIndent(node.parent);\n        checkNodesIndent(node, parentNodeIndent + indentSize);\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js":"/**\n * @fileoverview Validate closing bracket location in JSX\n * @author Yannick Croissant\n */\n'use strict';\n\nvar has = require('has');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Validate closing bracket location in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      oneOf: [\n        {\n          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']\n        },\n        {\n          type: 'object',\n          properties: {\n            location: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']\n            }\n          },\n          additionalProperties: false\n        }, {\n          type: 'object',\n          properties: {\n            nonEmpty: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]\n            },\n            selfClosing: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]\n            }\n          },\n          additionalProperties: false\n        }\n      ]\n    }]\n  },\n\n  create: function(context) {\n\n    var MESSAGE = 'The closing bracket must be {{location}}{{details}}';\n    var MESSAGE_LOCATION = {\n      'after-props': 'placed after the last prop',\n      'after-tag': 'placed after the opening tag',\n      'props-aligned': 'aligned with the last prop',\n      'tag-aligned': 'aligned with the opening tag',\n      'line-aligned': 'aligned with the line containing the opening tag'\n    };\n    var DEFAULT_LOCATION = 'tag-aligned';\n\n    var sourceCode = context.getSourceCode();\n    var config = context.options[0];\n    var options = {\n      nonEmpty: DEFAULT_LOCATION,\n      selfClosing: DEFAULT_LOCATION\n    };\n\n    if (typeof config === 'string') {\n      // simple shorthand [1, 'something']\n      options.nonEmpty = config;\n      options.selfClosing = config;\n    } else if (typeof config === 'object') {\n      // [1, {location: 'something'}] (back-compat)\n      if (has(config, 'location')) {\n        options.nonEmpty = config.location;\n        options.selfClosing = config.location;\n      }\n      // [1, {nonEmpty: 'something'}]\n      if (has(config, 'nonEmpty')) {\n        options.nonEmpty = config.nonEmpty;\n      }\n      // [1, {selfClosing: 'something'}]\n      if (has(config, 'selfClosing')) {\n        options.selfClosing = config.selfClosing;\n      }\n    }\n\n    /**\n     * Get expected location for the closing bracket\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @return {String} Expected location for the closing bracket\n     */\n    function getExpectedLocation(tokens) {\n      var location;\n      // Is always after the opening tag if there is no props\n      if (typeof tokens.lastProp === 'undefined') {\n        location = 'after-tag';\n      // Is always after the last prop if this one is on the same line as the opening bracket\n      } else if (tokens.opening.line === tokens.lastProp.lastLine) {\n        location = 'after-props';\n      // Else use configuration dependent on selfClosing property\n      } else {\n        location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;\n      }\n      return location;\n    }\n\n    /**\n     * Get the correct 0-indexed column for the closing bracket, given the\n     * expected location.\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {?Number} The correct column for the closing bracket, or null\n     */\n    function getCorrectColumn(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'props-aligned':\n          return tokens.lastProp.column;\n        case 'tag-aligned':\n          return tokens.opening.column;\n        case 'line-aligned':\n          return tokens.openingStartOfLine.column;\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Check if the closing bracket is correctly located\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {Boolean} True if the closing bracket is correctly located, false if not\n     */\n    function hasCorrectLocation(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'after-tag':\n          return tokens.tag.line === tokens.closing.line;\n        case 'after-props':\n          return tokens.lastProp.lastLine === tokens.closing.line;\n        case 'props-aligned':\n        case 'tag-aligned':\n        case 'line-aligned':\n          var correctColumn = getCorrectColumn(tokens, expectedLocation);\n          return correctColumn === tokens.closing.column;\n        default:\n          return true;\n      }\n    }\n\n    /**\n     * Get the characters used for indentation on the line to be matched\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @param {Number} correctColumn Expected column for the closing bracket\n     * @return {String} The characters used for indentation\n     */\n    function getIndentation(tokens, expectedLocation, correctColumn) {\n      var indentation, spaces = [];\n      switch (expectedLocation) {\n        case 'props-aligned':\n          indentation = /^\\s*/.exec(sourceCode.lines[tokens.lastProp.firstLine - 1])[0];\n          break;\n        case 'tag-aligned':\n        case 'line-aligned':\n          indentation = /^\\s*/.exec(sourceCode.lines[tokens.opening.line - 1])[0];\n          break;\n        default:\n          indentation = '';\n      }\n      if (indentation.length + 1 < correctColumn) {\n        // Non-whitespace characters were included in the column offset\n        spaces = new Array(+correctColumn + 1 - indentation.length);\n      }\n      return indentation + spaces.join(' ');\n    }\n\n    /**\n     * Get the locations of the opening bracket, closing bracket, last prop, and\n     * start of opening line.\n     * @param {ASTNode} node The node to check\n     * @return {Object} Locations of the opening bracket, closing bracket, last\n     * prop and start of opening line.\n     */\n    function getTokensLocations(node) {\n      var opening = sourceCode.getFirstToken(node).loc.start;\n      var closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;\n      var tag = sourceCode.getFirstToken(node.name).loc.start;\n      var lastProp;\n      if (node.attributes.length) {\n        lastProp = node.attributes[node.attributes.length - 1];\n        lastProp = {\n          column: sourceCode.getFirstToken(lastProp).loc.start.column,\n          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,\n          lastLine: sourceCode.getLastToken(lastProp).loc.end.line\n        };\n      }\n      var openingLine = sourceCode.lines[opening.line - 1];\n      var openingStartOfLine = {\n        column: /^\\s*/.exec(openingLine)[0].length,\n        line: opening.line\n      };\n      return {\n        tag: tag,\n        opening: opening,\n        closing: closing,\n        lastProp: lastProp,\n        selfClosing: node.selfClosing,\n        openingStartOfLine: openingStartOfLine\n      };\n    }\n\n    /**\n     * Get an unique ID for a given JSXOpeningElement\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {String} Unique ID (based on its range)\n     */\n    function getOpeningElementId(node) {\n      return node.range.join(':');\n    }\n\n    var lastAttributeNode = {};\n\n    return {\n      JSXAttribute: function(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      JSXSpreadAttribute: function(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      'JSXOpeningElement:exit': function(node) {\n        var attributeNode = lastAttributeNode[getOpeningElementId(node)];\n        var cachedLastAttributeEndPos = attributeNode ? attributeNode.end : null;\n        var expectedNextLine;\n        var tokens = getTokensLocations(node);\n        var expectedLocation = getExpectedLocation(tokens);\n\n        if (hasCorrectLocation(tokens, expectedLocation)) {\n          return;\n        }\n\n        var data = {location: MESSAGE_LOCATION[expectedLocation], details: ''};\n        var correctColumn = getCorrectColumn(tokens, expectedLocation);\n\n        if (correctColumn !== null) {\n          expectedNextLine = tokens.lastProp &&\n            (tokens.lastProp.lastLine === tokens.closing.line);\n          data.details = ' (expected column ' + (correctColumn + 1) +\n            (expectedNextLine ? ' on the next line)' : ')');\n        }\n\n        context.report({\n          node: node,\n          loc: tokens.closing,\n          message: MESSAGE,\n          data: data,\n          fix: function(fixer) {\n            var closingTag = tokens.selfClosing ? '/>' : '>';\n            switch (expectedLocation) {\n              case 'after-tag':\n                if (cachedLastAttributeEndPos) {\n                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end],\n                    (expectedNextLine ? '\\n' : '') + closingTag);\n                }\n                return fixer.replaceTextRange([node.name.range[1], node.end],\n                  (expectedNextLine ? '\\n' : ' ') + closingTag);\n              case 'after-props':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end],\n                  (expectedNextLine ? '\\n' : '') + closingTag);\n              case 'props-aligned':\n              case 'tag-aligned':\n              case 'line-aligned':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end],\n                  '\\n' + getIndentation(tokens, expectedLocation, correctColumn) + closingTag);\n              default:\n                return true;\n            }\n          }\n        });\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-space-before-closing.js":"/**\n * @fileoverview Validate spacing before closing bracket in JSX.\n * @author ryym\n */\n'use strict';\n\nvar getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Validate spacing before closing bracket in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      enum: ['always', 'never']\n    }]\n  },\n\n  create: function(context) {\n\n    var configuration = context.options[0] || 'always';\n    var sourceCode = context.getSourceCode();\n\n    var NEVER_MESSAGE = 'A space is forbidden before closing bracket';\n    var ALWAYS_MESSAGE = 'A space is required before closing bracket';\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXOpeningElement: function(node) {\n        if (!node.selfClosing) {\n          return;\n        }\n\n        var leftToken = getTokenBeforeClosingBracket(node);\n        var closingSlash = sourceCode.getTokenAfter(leftToken);\n\n        if (leftToken.loc.end.line !== closingSlash.loc.start.line) {\n          return;\n        }\n\n        if (configuration === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {\n          context.report({\n            loc: closingSlash.loc.start,\n            message: ALWAYS_MESSAGE,\n            fix: function(fixer) {\n              return fixer.insertTextBefore(closingSlash, ' ');\n            }\n          });\n        } else if (configuration === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {\n          context.report({\n            loc: closingSlash.loc.start,\n            message: NEVER_MESSAGE,\n            fix: function(fixer) {\n              var previousToken = sourceCode.getTokenBefore(closingSlash);\n              return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);\n            }\n          });\n        }\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/util/getTokenBeforeClosingBracket.js":"'use strict';\n\n/**\n * Find the token before the closing bracket.\n * @param {ASTNode} node - The JSX element node.\n * @returns {Token} The token before the closing bracket.\n */\nfunction getTokenBeforeClosingBracket(node) {\n  var attributes = node.attributes;\n  if (attributes.length === 0) {\n    return node.name;\n  }\n  return attributes[attributes.length - 1];\n}\n\nmodule.exports = getTokenBeforeClosingBracket;\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js":"/**\n * @fileoverview Prevent direct mutation of this.state\n * @author David Petersen\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent direct mutation of this.state',\n      category: 'Possible Errors',\n      recommended: true\n    }\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    /**\n     * Checks if the component is valid\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component is valid, false if not.\n     */\n    function isValid(component) {\n      return Boolean(component && !component.mutateSetState);\n    }\n\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMutations(component) {\n      var mutation;\n      for (var i = 0, j = component.mutations.length; i < j; i++) {\n        mutation = component.mutations[i];\n        context.report({\n          node: mutation,\n          message: 'Do not mutate state directly. Use setState().'\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      AssignmentExpression: function(node) {\n        var item;\n        if (!node.left || !node.left.object || !node.left.object.object) {\n          return;\n        }\n        item = node.left.object;\n        while (item.object.property) {\n          item = item.object;\n        }\n        if (\n          item.object.type === 'ThisExpression' &&\n          item.property.name === 'state'\n        ) {\n          var component = components.get(utils.getParentComponent());\n          var mutations = component && component.mutations || [];\n          mutations.push(node.left.object);\n          components.set(node, {\n            mutateSetState: true,\n            mutations: mutations\n          });\n        }\n      },\n\n      'Program:exit': function() {\n        var list = components.list();\n        for (var component in list) {\n          if (!has(list, component) || isValid(list[component])) {\n            continue;\n          }\n          reportMutations(list[component]);\n        }\n      }\n    };\n\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/forbid-component-props.js":"/**\n * @fileoverview Forbid certain props on components\n * @author Joe Lencioni\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = ['className', 'style'];\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Forbid certain props on components',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        forbid: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: true\n    }]\n  },\n\n  create: function(context) {\n\n    function isForbidden(prop) {\n      var configuration = context.options[0] || {};\n\n      var forbid = configuration.forbid || DEFAULTS;\n      return forbid.indexOf(prop) >= 0;\n    }\n\n    return {\n      JSXAttribute: function(node) {\n        var tag = node.parent.name.name;\n        if (tag && tag[0] !== tag[0].toUpperCase()) {\n          // This is a DOM node, not a Component, so exit.\n          return;\n        }\n\n        var prop = node.name.name;\n\n        if (!isForbidden(prop)) {\n          return;\n        }\n\n        context.report({\n          node: node,\n          message: 'Prop `' + prop + '` is forbidden on Components'\n        });\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/forbid-elements.js":"/**\n * @fileoverview Forbid certain elements\n * @author Kenneth Chung\n */\n'use strict';\n\nvar has = require('has');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Forbid certain elements',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        forbid: {\n          type: 'array',\n          items: {\n            anyOf: [\n              {type: 'string'},\n              {\n                type: 'object',\n                properties: {\n                  element: {type: 'string'},\n                  message: {type: 'string'}\n                },\n                required: ['element'],\n                additionalProperties: false\n              }\n            ]\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n    var sourceCode = context.getSourceCode();\n    var configuration = context.options[0] || {};\n    var forbidConfiguration = configuration.forbid || [];\n\n    var indexedForbidConfigs = {};\n\n    forbidConfiguration.forEach(function(item) {\n      if (typeof item === 'string') {\n        indexedForbidConfigs[item] = {element: item};\n      } else {\n        indexedForbidConfigs[item.element] = item;\n      }\n    });\n\n    function errorMessageForElement(name) {\n      var message = '<' + name + '> is forbidden';\n      var additionalMessage = indexedForbidConfigs[name].message;\n\n      if (additionalMessage) {\n        message = message + ', ' + additionalMessage;\n      }\n\n      return message;\n    }\n\n    function isValidCreateElement(node) {\n      return node.callee\n        && node.callee.type === 'MemberExpression'\n        && node.callee.object.name === 'React'\n        && node.callee.property.name === 'createElement'\n        && node.arguments.length > 0;\n    }\n\n    function reportIfForbidden(element, node) {\n      if (has(indexedForbidConfigs, element)) {\n        context.report({\n          node: node,\n          message: errorMessageForElement(element)\n        });\n      }\n    }\n\n    return {\n      JSXOpeningElement: function(node) {\n        reportIfForbidden(sourceCode.getText(node.name), node.name);\n      },\n\n      CallExpression: function(node) {\n        if (!isValidCreateElement(node)) {\n          return;\n        }\n\n        var argument = node.arguments[0];\n        var argType = argument.type;\n\n        if (argType === 'Identifier' && /^[A-Z_]/.test(argument.name)) {\n          reportIfForbidden(argument.name, argument);\n        } else if (argType === 'Literal' && /^[a-z][^\\.]*$/.test(argument.value)) {\n          reportIfForbidden(argument.value, argument);\n        } else if (argType === 'MemberExpression') {\n          reportIfForbidden(sourceCode.getText(argument), argument);\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js":"/**\n * @fileoverview Forbid certain propTypes\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = ['any', 'array', 'object'];\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Forbid certain propTypes',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        forbid: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: true\n    }]\n  },\n\n  create: function(context) {\n\n    function isForbidden(type) {\n      var configuration = context.options[0] || {};\n\n      var forbid = configuration.forbid || DEFAULTS;\n      return forbid.indexOf(type) >= 0;\n    }\n\n    /**\n     * Checks if node is `propTypes` declaration\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is `propTypes` declaration, false if not.\n     */\n    function isPropTypesDeclaration(node) {\n\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        if (tokens[0].value === 'propTypes' || (tokens[1] && tokens[1].value === 'propTypes')) {\n          return true;\n        }\n        return false;\n      }\n\n      return Boolean(\n        node &&\n        node.name === 'propTypes'\n      );\n    }\n\n\n    /**\n     * Checks if propTypes declarations are forbidden\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n    function checkForbidden(declarations) {\n      declarations.forEach(function(declaration) {\n        if (declaration.type !== 'Property') {\n          return;\n        }\n        var target;\n        var value = declaration.value;\n        if (\n          value.type === 'MemberExpression' &&\n          value.property &&\n          value.property.name &&\n          value.property.name === 'isRequired'\n        ) {\n          value = value.object;\n        }\n        if (\n          value.type === 'CallExpression' &&\n          value.callee.type === 'MemberExpression'\n        ) {\n          value = value.callee;\n        }\n        if (value.property) {\n          target = value.property.name;\n        } else if (value.type === 'Identifier') {\n          target = value.name;\n        }\n        if (isForbidden(target)) {\n          context.report({\n            node: declaration,\n            message: 'Prop type `' + target + '` is forbidden'\n          });\n        }\n      });\n    }\n\n    return {\n      ClassProperty: function(node) {\n        if (isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {\n          checkForbidden(node.value.properties);\n        }\n      },\n\n      MemberExpression: function(node) {\n        if (isPropTypesDeclaration(node.property)) {\n          var right = node.parent.right;\n          if (right && right.type === 'ObjectExpression') {\n            checkForbidden(right.properties);\n          }\n        }\n      },\n\n      ObjectExpression: function(node) {\n        node.properties.forEach(function(property) {\n          if (!property.key) {\n            return;\n          }\n\n          if (!isPropTypesDeclaration(property.key)) {\n            return;\n          }\n          if (property.value.type === 'ObjectExpression') {\n            checkForbidden(property.value.properties);\n          }\n        });\n      }\n\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/forbid-foreign-prop-types.js":"/**\n * @fileoverview Forbid using another component's propTypes\n * @author Ian Christian Myers\n */\n'use strict';\n\nvar find = require('array.prototype.find');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Forbid using another component\\'s propTypes',\n      category: 'Best Practices',\n      recommended: false\n    }\n  },\n\n  create: function(context) {\n    // --------------------------------------------------------------------------\n    // Helpers\n    // --------------------------------------------------------------------------\n\n    function isLeftSideOfAssignment(node) {\n      return node.parent.type === 'AssignmentExpression' && node.parent.left === node;\n    }\n\n    return {\n      MemberExpression: function(node) {\n        if (!node.computed && node.property && node.property.type === 'Identifier' &&\n            node.property.name === 'propTypes' && !isLeftSideOfAssignment(node) ||\n            node.property && node.property.type === 'Literal' &&\n            node.property.value === 'propTypes' && !isLeftSideOfAssignment(node)) {\n          context.report({\n            node: node.property,\n            message: 'Using another component\\'s propTypes is forbidden'\n          });\n        }\n      },\n\n      ObjectPattern: function(node) {\n        var propTypesNode = find(node.properties, function(property) {\n          return property.type === 'Property' && property.key.name === 'propTypes';\n        });\n\n        if (propTypesNode) {\n          context.report({\n            node: propTypesNode,\n            message: 'Using another component\\'s propTypes is forbidden'\n          });\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js":"/**\n * @fileoverview Enforce ES5 or ES6 class for React Components\n * @author Dan Hamilton\n */\n'use strict';\n\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce ES5 or ES6 class for React Components',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      enum: ['always', 'never']\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n    var configuration = context.options[0] || 'always';\n\n    return {\n      ObjectExpression: function(node) {\n        if (utils.isES5Component(node) && configuration === 'always') {\n          context.report({\n            node: node,\n            message: 'Component should use es6 class instead of createClass'\n          });\n        }\n      },\n      ClassDeclaration: function(node) {\n        if (utils.isES6Component(node) && configuration === 'never') {\n          context.report({\n            node: node,\n            message: 'Component should use createClass instead of es6 class'\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-key.js":"/**\n * @fileoverview Report missing `key` props in iterators/collection literals.\n * @author Ben Mosher\n */\n'use strict';\n\n// var Components = require('../util/Components');\nvar hasProp = require('jsx-ast-utils/hasProp');\n\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Report missing `key` props in iterators/collection literals',\n      category: 'Possible Errors',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    function checkIteratorElement(node) {\n      if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {\n        context.report({\n          node: node,\n          message: 'Missing \"key\" prop for element in iterator'\n        });\n      }\n    }\n\n    function getReturnStatement(body) {\n      return body.filter(function(item) {\n        return item.type === 'ReturnStatement';\n      })[0];\n    }\n\n    return {\n      JSXElement: function(node) {\n        if (hasProp(node.openingElement.attributes, 'key')) {\n          return;\n        }\n\n        if (node.parent.type === 'ArrayExpression') {\n          context.report({\n            node: node,\n            message: 'Missing \"key\" prop for element in array'\n          });\n        }\n      },\n\n      // Array.prototype.map\n      CallExpression: function (node) {\n        if (node.callee && node.callee.type !== 'MemberExpression') {\n          return;\n        }\n\n        if (node.callee && node.callee.property && node.callee.property.name !== 'map') {\n          return;\n        }\n\n        var fn = node.arguments[0];\n        var isFn = fn && fn.type === 'FunctionExpression';\n        var isArrFn = fn && fn.type === 'ArrowFunctionExpression';\n\n        if (isArrFn && fn.body.type === 'JSXElement') {\n          checkIteratorElement(fn.body);\n        }\n\n        if (isFn || isArrFn) {\n          if (fn.body.type === 'BlockStatement') {\n            var returnStatement = getReturnStatement(fn.body.body);\n            if (returnStatement && returnStatement.argument) {\n              checkIteratorElement(returnStatement.argument);\n            }\n          }\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js":"/**\n * @fileoverview Prevent string definitions for references and prevent referencing this.refs\n * @author Tom Hastjarjanto\n */\n'use strict';\n\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent string definitions for references and prevent referencing this.refs',\n      category: 'Best Practices',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: Components.detect(function(context, components, utils) {\n    /**\n     * Checks if we are using refs\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are using refs, false if not.\n     */\n    function isRefsUsage(node) {\n      return Boolean(\n        (\n          utils.getParentES6Component() ||\n          utils.getParentES5Component()\n        ) &&\n        node.object.type === 'ThisExpression' &&\n        node.property.name === 'refs'\n      );\n    }\n\n    /**\n     * Checks if we are using a ref attribute\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are using a ref attribute, false if not.\n     */\n    function isRefAttribute(node) {\n      return Boolean(\n        node.type === 'JSXAttribute' &&\n        node.name &&\n        node.name.name === 'ref'\n      );\n    }\n\n    /**\n     * Checks if a node contains a string value\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node contains a string value, false if not.\n     */\n    function containsStringLiteral(node) {\n      return Boolean(\n        node.value &&\n        node.value.type === 'Literal' &&\n        typeof node.value.value === 'string'\n      );\n    }\n\n    /**\n     * Checks if a node contains a string value within a jsx expression\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node contains a string value within a jsx expression, false if not.\n     */\n    function containsStringExpressionContainer(node) {\n      return Boolean(\n        node.value &&\n        node.value.type === 'JSXExpressionContainer' &&\n        node.value.expression &&\n        node.value.expression.type === 'Literal' &&\n        typeof node.value.expression.value === 'string'\n      );\n    }\n\n    return {\n      MemberExpression: function(node) {\n        if (isRefsUsage(node)) {\n          context.report({\n            node: node,\n            message: 'Using this.refs is deprecated.'\n          });\n        }\n      },\n      JSXAttribute: function(node) {\n        if (\n          isRefAttribute(node) &&\n          (containsStringLiteral(node) || containsStringExpressionContainer(node))\n        ) {\n          context.report({\n            node: node,\n            message: 'Using string literals in ref attributes is deprecated.'\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/prefer-stateless-function.js":"/**\n * @fileoverview Enforce stateless components to be written as a pure function\n * @author Yannick Croissant\n * @author Alberto Rodríguez\n * @copyright 2015 Alberto Rodríguez. All rights reserved.\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\nvar versionUtil = require('../util/version');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce stateless components to be written as a pure function',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignorePureComponents: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    var configuration = context.options[0] || {};\n    var ignorePureComponents = configuration.ignorePureComponents || false;\n\n    var sourceCode = context.getSourceCode();\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n    function getPropertyName(node) {\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;\n      }\n\n      return node.key.name;\n    }\n\n    /**\n     * Get properties for a given AST node\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Array} Properties array.\n     */\n    function getComponentProperties(node) {\n      switch (node.type) {\n        case 'ClassExpression':\n        case 'ClassDeclaration':\n          return node.body.body;\n        case 'ObjectExpression':\n          return node.properties;\n        default:\n          return [];\n      }\n    }\n\n    /**\n     * Checks whether a given array of statements is a single call of `super`.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode[]} body - An array of statements to check.\n     * @returns {boolean} `true` if the body is a single call of `super`.\n     */\n    function isSingleSuperCall(body) {\n      return (\n        body.length === 1 &&\n        body[0].type === 'ExpressionStatement' &&\n        body[0].expression.type === 'CallExpression' &&\n        body[0].expression.callee.type === 'Super'\n      );\n    }\n\n    /**\n     * Checks whether a given node is a pattern which doesn't have any side effects.\n     * Default parameters and Destructuring parameters can have side effects.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode} node - A pattern node.\n     * @returns {boolean} `true` if the node doesn't have any side effects.\n     */\n    function isSimple(node) {\n      return node.type === 'Identifier' || node.type === 'RestElement';\n    }\n\n    /**\n     * Checks whether a given array of expressions is `...arguments` or not.\n     * `super(...arguments)` passes all arguments through.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode[]} superArgs - An array of expressions to check.\n     * @returns {boolean} `true` if the superArgs is `...arguments`.\n     */\n    function isSpreadArguments(superArgs) {\n      return (\n        superArgs.length === 1 &&\n        superArgs[0].type === 'SpreadElement' &&\n        superArgs[0].argument.type === 'Identifier' &&\n        superArgs[0].argument.name === 'arguments'\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are identifiers which have the same name or not.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are identifiers which have the same\n     *      name.\n     */\n    function isValidIdentifierPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'Identifier' &&\n        superArg.type === 'Identifier' &&\n        ctorParam.name === superArg.name\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n     *      same values.\n     */\n    function isValidRestSpreadPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'RestElement' &&\n        superArg.type === 'SpreadElement' &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes have the same value or not.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes have the same value or not.\n     */\n    function isValidPair(ctorParam, superArg) {\n      return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n      );\n    }\n\n    /**\n     * Checks whether the parameters of a constructor and the arguments of `super()`\n     * have the same values or not.\n     * @see ESLint no-useless-constructor rule\n     * @param {ASTNode} ctorParams - The parameters of a constructor to check.\n     * @param {ASTNode} superArgs - The arguments of `super()` to check.\n     * @returns {boolean} `true` if those have the same values.\n     */\n    function isPassingThrough(ctorParams, superArgs) {\n      if (ctorParams.length !== superArgs.length) {\n        return false;\n      }\n\n      for (var i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Checks whether the constructor body is a redundant super call.\n     * @see ESLint no-useless-constructor rule\n     * @param {Array} body - constructor body content.\n     * @param {Array} ctorParams - The params to check against super call.\n     * @returns {boolean} true if the construtor body is redundant\n     */\n    function isRedundantSuperCall(body, ctorParams) {\n      return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n          isSpreadArguments(body[0].expression.arguments) ||\n          isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n      );\n    }\n\n    /**\n     * Check if a given AST node have any other properties the ones available in stateless components\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node has at least one other property, false if not.\n     */\n    function hasOtherProperties(node) {\n      var properties = getComponentProperties(node);\n      return properties.some(function(property) {\n        var name = getPropertyName(property);\n        var isDisplayName = name === 'displayName';\n        var isPropTypes = name === 'propTypes' || name === 'props' && property.typeAnnotation;\n        var contextTypes = name === 'contextTypes';\n        var isUselessConstructor =\n          property.kind === 'constructor' &&\n          isRedundantSuperCall(property.value.body.body, property.value.params)\n        ;\n        var isRender = name === 'render';\n        return !isDisplayName && !isPropTypes && !contextTypes && !isUselessConstructor && !isRender;\n      });\n    }\n\n    /**\n     * Mark component as pure as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    var markSCUAsDeclared = function (node) {\n      components.set(node, {\n        hasSCU: true\n      });\n    };\n\n    /**\n     * Mark childContextTypes as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    var markChildContextTypesAsDeclared = function (node) {\n      components.set(node, {\n        hasChildContextTypes: true\n      });\n    };\n\n    /**\n     * Mark a setState as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markThisAsUsed(node) {\n      components.set(node, {\n        useThis: true\n      });\n    }\n\n    /**\n     * Mark a props or context as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markPropsOrContextAsUsed(node) {\n      components.set(node, {\n        usePropsOrContext: true\n      });\n    }\n\n    /**\n     * Mark a ref as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markRefAsUsed(node) {\n      components.set(node, {\n        useRef: true\n      });\n    }\n\n    /**\n     * Mark return as invalid\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markReturnAsInvalid(node) {\n      components.set(node, {\n        invalidReturn: true\n      });\n    }\n\n    return {\n      ClassDeclaration: function (node) {\n        if (ignorePureComponents && utils.isPureComponent(node)) {\n          markSCUAsDeclared(node);\n        }\n      },\n\n      // Mark `this` destructuring as a usage of `this`\n      VariableDeclarator: function(node) {\n        // Ignore destructuring on other than `this`\n        if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {\n          return;\n        }\n        // Ignore `props` and `context`\n        var useThis = node.id.properties.some(function(property) {\n          var name = getPropertyName(property);\n          return name !== 'props' && name !== 'context';\n        });\n        if (!useThis) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `this` usage\n      MemberExpression: function(node) {\n        if (node.object.type !== 'ThisExpression') {\n          if (node.property && node.property.name === 'childContextTypes') {\n            var component = utils.getRelatedComponent(node);\n            if (!component) {\n              return;\n            }\n            markChildContextTypesAsDeclared(component.node);\n            return;\n          }\n          return;\n        // Ignore calls to `this.props` and `this.context`\n        } else if (\n          (node.property.name || node.property.value) === 'props' ||\n          (node.property.name || node.property.value) === 'context'\n        ) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `ref` usage\n      JSXAttribute: function(node) {\n        var name = sourceCode.getText(node.name);\n        if (name !== 'ref') {\n          return;\n        }\n        markRefAsUsed(node);\n      },\n\n      // Mark `render` that do not return some JSX\n      ReturnStatement: function(node) {\n        var blockNode;\n        var scope = context.getScope();\n        while (scope) {\n          blockNode = scope.block && scope.block.parent;\n          if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {\n            break;\n          }\n          scope = scope.upper;\n        }\n        var isRender = blockNode && blockNode.key && blockNode.key.name === 'render';\n        var allowNull = versionUtil.test(context, '15.0.0'); // Stateless components can return null since React 15\n        var isReturningJSX = utils.isReturningJSX(node, !allowNull);\n        var isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);\n        if (\n          !isRender ||\n          (allowNull && (isReturningJSX || isReturningNull)) ||\n          (!allowNull && isReturningJSX)\n        ) {\n          return;\n        }\n        markReturnAsInvalid(node);\n      },\n\n      'Program:exit': function() {\n        var list = components.list();\n        for (var component in list) {\n          if (\n            !has(list, component) ||\n            hasOtherProperties(list[component].node) ||\n            list[component].useThis ||\n            list[component].useRef ||\n            list[component].invalidReturn ||\n            list[component].hasChildContextTypes ||\n            (!utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node))\n          ) {\n            continue;\n          }\n\n          if (list[component].hasSCU && list[component].usePropsOrContext) {\n            continue;\n          }\n\n          context.report({\n            node: list[component].node,\n            message: 'Component should be written as a pure function'\n          });\n        }\n      }\n    };\n\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/require-render-return.js":"/**\n * @fileoverview Enforce ES5 or ES6 class for returning value in render function.\n * @author Mark Orel\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce ES5 or ES6 class for returning value in render function',\n      category: 'Possible Errors',\n      recommended: true\n    },\n    schema: [{}]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    /**\n     * Mark a return statement as present\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markReturnStatementPresent(node) {\n      components.set(node, {\n        hasReturnStatement: true\n      });\n    }\n\n    /**\n     * Get properties for a given AST node\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Array} Properties array.\n     */\n    function getComponentProperties(node) {\n      switch (node.type) {\n        case 'ClassDeclaration':\n          return node.body.body;\n        case 'ObjectExpression':\n          return node.properties;\n        default:\n          return [];\n      }\n    }\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {String} Property name.\n     */\n    function getPropertyName(node) {\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;\n      } else if (['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n        return node.key.name;\n      }\n      return '';\n    }\n\n    /**\n     * Check if a given AST node has a render method\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if there is a render method, false if not\n     */\n    function hasRenderMethod(node) {\n      var properties = getComponentProperties(node);\n      for (var i = 0, j = properties.length; i < j; i++) {\n        if (getPropertyName(properties[i]) !== 'render' || !properties[i].value) {\n          continue;\n        }\n        return /FunctionExpression$/.test(properties[i].value.type);\n      }\n      return false;\n    }\n\n    return {\n      ReturnStatement: function(node) {\n        var ancestors = context.getAncestors(node).reverse();\n        var depth = 0;\n        for (var i = 0, j = ancestors.length; i < j; i++) {\n          if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {\n            depth++;\n          }\n          if (\n            !/(MethodDefinition|(Class)?Property)$/.test(ancestors[i].type) ||\n            getPropertyName(ancestors[i]) !== 'render' ||\n            depth > 1\n          ) {\n            continue;\n          }\n          markReturnStatementPresent(node);\n        }\n      },\n\n      ArrowFunctionExpression: function(node) {\n        if (node.expression === false || getPropertyName(node.parent) !== 'render') {\n          return;\n        }\n        markReturnStatementPresent(node);\n      },\n\n      'Program:exit': function() {\n        var list = components.list();\n        for (var component in list) {\n          if (\n            !has(list, component) ||\n            !hasRenderMethod(list[component].node) ||\n            list[component].hasReturnStatement ||\n            (!utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node))\n          ) {\n            continue;\n          }\n          context.report({\n            node: list[component].node,\n            message: 'Your render method should have return statement'\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-first-prop-new-line.js":"/**\n * @fileoverview Ensure proper position of the first property in JSX\n * @author Joachim Seminck\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Ensure proper position of the first property in JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      enum: ['always', 'never', 'multiline', 'multiline-multiprop']\n    }]\n  },\n\n  create: function (context) {\n    var configuration = context.options[0];\n\n    function isMultilineJSX(jsxNode) {\n      return jsxNode.loc.start.line < jsxNode.loc.end.line;\n    }\n\n    return {\n      JSXOpeningElement: function (node) {\n        if (\n          (configuration === 'multiline' && isMultilineJSX(node)) ||\n          (configuration === 'multiline-multiprop' && isMultilineJSX(node) && node.attributes.length > 1) ||\n          (configuration === 'always')\n        ) {\n          node.attributes.some(function(decl) {\n            if (decl.loc.start.line === node.loc.start.line) {\n              context.report({\n                node: decl,\n                message: 'Property should be placed on a new line',\n                fix: function(fixer) {\n                  return fixer.replaceTextRange([node.name.end, decl.start], '\\n');\n                }\n              });\n            }\n            return true;\n          });\n        } else if (configuration === 'never' && node.attributes.length > 0) {\n          var firstNode = node.attributes[0];\n          if (node.loc.start.line < firstNode.loc.start.line) {\n            context.report({\n              node: firstNode,\n              message: 'Property should be placed on the same line as the component declaration',\n              fix: function(fixer) {\n                return fixer.replaceTextRange([node.name.end, firstNode.start], ' ');\n              }\n            });\n            return;\n          }\n        }\n        return;\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-no-target-blank.js":"/**\n * @fileoverview Forbid target='_blank' attribute\n * @author Kevin Miller\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Forbid target=\"_blank\" attribute without rel=\"noopener noreferrer\"',\n      category: 'Best Practices',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: function(context) {\n    return {\n      JSXAttribute: function(node) {\n        if (node.parent.name.name !== 'a') {\n          return;\n        }\n\n        if (\n          node.name.name === 'target' &&\n          node.value.type === 'Literal' &&\n          node.value.value.toLowerCase() === '_blank'\n        ) {\n          var relFound = false;\n          var attrs = node.parent.attributes;\n          for (var idx in attrs) {\n            if (attrs[idx].name && attrs[idx].name.name === 'rel') {\n              var tags = attrs[idx].value.type === 'Literal' && attrs[idx].value.value.toLowerCase().split(' ');\n              if (!tags || (tags.indexOf('noopener') >= 0 && tags.indexOf('noreferrer') >= 0)) {\n                relFound = true;\n                break;\n              }\n            }\n          }\n          if (!relFound) {\n            context.report(node, 'Using target=\"_blank\" without rel=\"noopener noreferrer\" ' +\n            'is a security risk: see https://mathiasbynens.github.io/rel-noopener');\n          }\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-filename-extension.js":"/**\n * @fileoverview Restrict file extensions that may contain JSX\n * @author Joe Lencioni\n */\n'use strict';\n\nvar path = require('path');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = {\n  extensions: ['.jsx']\n};\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Restrict file extensions that may contain JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        extensions: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n\n    function getExtensionsConfig() {\n      return context.options[0] && context.options[0].extensions || DEFAULTS.extensions;\n    }\n\n    var invalidExtension;\n    var invalidNode;\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXElement: function(node) {\n        var filename = context.getFilename();\n        if (filename === '<text>') {\n          return;\n        }\n\n        if (invalidNode) {\n          return;\n        }\n\n        var allowedExtensions = getExtensionsConfig();\n        var isAllowedExtension = allowedExtensions.some(function (extension) {\n          return filename.slice(-extension.length) === extension;\n        });\n\n        if (isAllowedExtension) {\n          return;\n        }\n\n        invalidNode = node;\n        invalidExtension = path.extname(filename);\n      },\n\n      'Program:exit': function() {\n        if (!invalidNode) {\n          return;\n        }\n\n        context.report({\n          node: invalidNode,\n          message: 'JSX not allowed in files with extension \\'' + invalidExtension + '\\''\n        });\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/require-optimization.js":"/**\n * @fileoverview Enforce React components to have a shouldComponentUpdate method\n * @author Evgueni Naverniouk\n */\n'use strict';\n\nvar has = require('has');\nvar Components = require('../util/Components');\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce React components to have a shouldComponentUpdate method',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowDecorators: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function (context, components, utils) {\n    var MISSING_MESSAGE = 'Component is not optimized. Please add a shouldComponentUpdate method.';\n    var configuration = context.options[0] || {};\n    var allowDecorators = configuration.allowDecorators || [];\n\n    /**\n     * Checks to see if our component is decorated by PureRenderMixin via reactMixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated with a PureRenderMixin, false if not.\n     */\n    var hasPureRenderDecorator = function (node) {\n      if (node.decorators && node.decorators.length) {\n        for (var i = 0, l = node.decorators.length; i < l; i++) {\n          if (\n            node.decorators[i].expression &&\n            node.decorators[i].expression.callee &&\n            node.decorators[i].expression.callee.object &&\n            node.decorators[i].expression.callee.object.name === 'reactMixin' &&\n            node.decorators[i].expression.callee.property &&\n            node.decorators[i].expression.callee.property.name === 'decorate' &&\n            node.decorators[i].expression.arguments &&\n            node.decorators[i].expression.arguments.length &&\n            node.decorators[i].expression.arguments[0].name === 'PureRenderMixin'\n          ) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    /**\n     * Checks to see if our component is custom decorated\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated name with a custom decorated, false if not.\n     */\n    var hasCustomDecorator = function (node) {\n      var allowLength = allowDecorators.length;\n\n      if (allowLength && node.decorators && node.decorators.length) {\n        for (var i = 0; i < allowLength; i++) {\n          for (var j = 0, l = node.decorators.length; j < l; j++) {\n            if (\n              node.decorators[j].expression &&\n              node.decorators[j].expression.name === allowDecorators[i]\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    };\n\n    /**\n     * Checks if we are declaring a shouldComponentUpdate method\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a shouldComponentUpdate method, false if not.\n     */\n    var isSCUDeclarеd = function (node) {\n      return Boolean(\n        node &&\n        node.name === 'shouldComponentUpdate'\n      );\n    };\n\n    /**\n     * Checks if we are declaring a PureRenderMixin mixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a PureRenderMixin method, false if not.\n     */\n    var isPureRenderDeclared = function (node) {\n      var hasPR = false;\n      if (node.value && node.value.elements) {\n        for (var i = 0, l = node.value.elements.length; i < l; i++) {\n          if (node.value.elements[i].name === 'PureRenderMixin') {\n            hasPR = true;\n            break;\n          }\n        }\n      }\n\n      return Boolean(\n          node &&\n          node.key.name === 'mixins' &&\n          hasPR\n        );\n    };\n\n    /**\n     * Mark shouldComponentUpdate as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    var markSCUAsDeclared = function (node) {\n      components.set(node, {\n        hasSCU: true\n      });\n    };\n\n    /**\n     * Reports missing optimization for a given component\n     * @param {Object} component The component to process\n     */\n    var reportMissingOptimization = function (component) {\n      context.report({\n        node: component.node,\n        message: MISSING_MESSAGE,\n        data: {\n          component: component.name\n        }\n      });\n    };\n\n    /**\n     * Checks if we are declaring function in class\n     * @returns {Boolean} True if we are declaring function in class, false if not.\n     */\n    var isFunctionInClass = function () {\n      var blockNode;\n      var scope = context.getScope();\n      while (scope) {\n        blockNode = scope.block;\n        if (blockNode && blockNode.type === 'ClassDeclaration') {\n          return true;\n        }\n        scope = scope.upper;\n      }\n\n      return false;\n    };\n\n    return {\n      ArrowFunctionExpression: function (node) {\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      ClassDeclaration: function (node) {\n        if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || utils.isPureComponent(node))) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      FunctionDeclaration: function (node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      FunctionExpression: function (node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      MethodDefinition: function (node) {\n        if (!isSCUDeclarеd(node.key)) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      ObjectExpression: function (node) {\n        // Search for the shouldComponentUpdate declaration\n        for (var i = 0, l = node.properties.length; i < l; i++) {\n          if (\n            !node.properties[i].key || (\n              !isSCUDeclarеd(node.properties[i].key) &&\n              !isPureRenderDeclared(node.properties[i])\n            )\n          ) {\n            continue;\n          }\n          markSCUAsDeclared(node);\n        }\n      },\n\n      'Program:exit': function () {\n        var list = components.list();\n\n        // Report missing shouldComponentUpdate for all components\n        for (var component in list) {\n          if (!has(list, component) || list[component].hasSCU) {\n            continue;\n          }\n          reportMissingOptimization(list[component]);\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-find-dom-node.js":"/**\n * @fileoverview Prevent usage of findDOMNode\n * @author Yannick Croissant\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent usage of findDOMNode',\n      category: 'Best Practices',\n      recommended: true\n    },\n    schema: []\n  },\n\n  create: function(context) {\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        var callee = node.callee;\n\n        var isfindDOMNode =\n          (callee.object && callee.object.callee && callee.object.callee.name === 'findDOMNode') ||\n          (callee.property && callee.property.name === 'findDOMNode')\n        ;\n\n        if (!isfindDOMNode) {\n          return;\n        }\n\n        context.report({\n          node: callee,\n          message: 'Do not use findDOMNode'\n        });\n      }\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-danger-with-children.js":"/**\n * @fileoverview Report when a DOM element is using both children and dangerouslySetInnerHTML\n * @author David Petersen\n */\n'use strict';\n\nvar find = require('array.prototype.find');\nvar variableUtil = require('../util/variable');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Report when a DOM element is using both children and dangerouslySetInnerHTML',\n      category: '',\n      recommended: false\n    },\n    schema: [] // no options\n  },\n  create: function(context) {\n    function findSpreadVariable(name) {\n      return find(variableUtil.variablesInScope(context), function (item) {\n        return item.name === name;\n      });\n    }\n    /**\n     * Takes a ObjectExpression and returns the value of the prop if it has it\n     * @param {object} node - ObjectExpression node\n     * @param {string} propName - name of the prop to look for\n     */\n    function findObjectProp(node, propName) {\n      if (!node.properties) {\n        return false;\n      }\n      return find(node.properties, function(prop) {\n        if (prop.type === 'Property') {\n          return prop.key.name === propName;\n        } else if (prop.type === 'ExperimentalSpreadProperty') {\n          var variable = findSpreadVariable(prop.argument.name);\n          if (variable && variable.defs[0].node.init) {\n            return findObjectProp(variable.defs[0].node.init, propName);\n          }\n        }\n        return false;\n      });\n    }\n\n    /**\n     * Takes a JSXElement and returns the value of the prop if it has it\n     * @param {object} node - JSXElement node\n     * @param {string} propName - name of the prop to look for\n     */\n    function findJsxProp(node, propName) {\n      var attributes = node.openingElement.attributes;\n      return find(attributes, function (attribute) {\n        if (attribute.type === 'JSXSpreadAttribute') {\n          var variable = findSpreadVariable(attribute.argument.name);\n          if (variable && variable.defs.length && variable.defs[0].node.init) {\n            return findObjectProp(variable.defs[0].node.init, propName);\n          }\n        }\n        return attribute.name && attribute.name.name === propName;\n      });\n    }\n\n    return {\n      JSXElement: function (node) {\n        var hasChildren = false;\n\n        if (node.children.length) {\n          hasChildren = true;\n        } else if (findJsxProp(node, 'children')) {\n          hasChildren = true;\n        }\n\n        if (\n          node.openingElement.attributes\n          && hasChildren\n          && findJsxProp(node, 'dangerouslySetInnerHTML')\n        ) {\n          context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');\n        }\n      },\n      CallExpression: function (node) {\n        if (\n          node.callee\n          && node.callee.type === 'MemberExpression'\n          && node.callee.property.name === 'createElement'\n          && node.arguments.length > 1\n        ) {\n          var hasChildren = false;\n\n          var props = node.arguments[1];\n\n          if (props.type === 'Identifier') {\n            var variable = find(variableUtil.variablesInScope(context), function (item) {\n              return item.name === props.name;\n            });\n            if (variable && variable.defs[0].node.init) {\n              props = variable.defs[0].node.init;\n            }\n          }\n\n          var dangerously = findObjectProp(props, 'dangerouslySetInnerHTML');\n\n          if (node.arguments.length === 2) {\n            if (findObjectProp(props, 'children')) {\n              hasChildren = true;\n            }\n          } else {\n            hasChildren = true;\n          }\n\n          if (dangerously && hasChildren) {\n            context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');\n          }\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/style-prop-object.js":"/**\n * @fileoverview Enforce style prop value is an object\n * @author David Petersen\n */\n'use strict';\n\nvar find = require('array.prototype.find');\nvar variableUtil = require('../util/variable');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce style prop value is an object',\n      category: '',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: function(context) {\n    /**\n     * @param {object} node An Identifier node\n     */\n    function isNonNullaryLiteral(expression) {\n      return expression.type === 'Literal' && expression.value !== null;\n    }\n\n    /**\n     * @param {object} node A Identifier node\n     */\n    function checkIdentifiers(node) {\n      var variable = find(variableUtil.variablesInScope(context), function (item) {\n        return item.name === node.name;\n      });\n\n      if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {\n        return;\n      }\n\n      if (isNonNullaryLiteral(variable.defs[0].node.init)) {\n        context.report(node, 'Style prop value must be an object');\n      }\n    }\n\n    return {\n      CallExpression: function(node) {\n        if (\n          node.callee\n          && node.callee.type === 'MemberExpression'\n          && node.callee.property.name === 'createElement'\n          && node.arguments.length > 1\n        ) {\n          if (node.arguments[1].type === 'ObjectExpression') {\n            var style = find(node.arguments[1].properties, function(property) {\n              return property.key && property.key.name === 'style' && !property.computed;\n            });\n            if (style) {\n              if (style.value.type === 'Identifier') {\n                checkIdentifiers(style.value);\n              } else if (isNonNullaryLiteral(style.value)) {\n                context.report(style.value, 'Style prop value must be an object');\n              }\n            }\n          }\n        }\n      },\n\n      JSXAttribute: function(node) {\n        if (!node.value || node.name.name !== 'style') {\n          return;\n        }\n\n        if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {\n          context.report(node, 'Style prop value must be an object');\n        } else if (node.value.expression.type === 'Identifier') {\n          checkIdentifiers(node.value.expression);\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-unused-prop-types.js":"/**\n * @fileoverview Prevent definitions of unused prop types\n * @author Evgueni Naverniouk\n */\n'use strict';\n\n// As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/yannickcr/eslint-plugin-react/issues/7\n\nvar has = require('has');\nvar assign = require('object.assign');\nvar Components = require('../util/Components');\nvar variable = require('../util/variable');\nvar annotations = require('../util/annotations');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DIRECT_PROPS_REGEX = /^props\\s*(\\.|\\[)/;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent definitions of unused prop types',\n      category: 'Best Practices',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        skipShapeProps: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: Components.detect(function(context, components, utils) {\n\n    var defaults = {skipShapeProps: true};\n    var sourceCode = context.getSourceCode();\n    var configuration = assign({}, defaults, context.options[0] || {});\n    var skipShapeProps = configuration.skipShapeProps;\n    var customValidators = configuration.customValidators || [];\n    // Used to track the type annotations in scope.\n    // Necessary because babel's scopes do not track type annotations.\n    var stack = null;\n\n    var UNUSED_MESSAGE = '\\'{{name}}\\' PropType is defined but prop is never used';\n\n    /**\n     * Helper for accessing the current scope in the stack.\n     * @param {string} key The name of the identifier to access. If omitted, returns the full scope.\n     * @param {ASTNode} value If provided sets the new value for the identifier.\n     * @returns {Object|ASTNode} Either the whole scope or the ASTNode associated with the given identifier.\n     */\n    function typeScope(key, value) {\n      if (arguments.length === 0) {\n        return stack[stack.length - 1];\n      } else if (arguments.length === 1) {\n        return stack[stack.length - 1][key];\n      }\n      stack[stack.length - 1][key] = value;\n      return value;\n    }\n\n    /**\n     * Checks if we are using a prop\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are using a prop, false if not.\n     */\n    function isPropTypesUsage(node) {\n      var isClassUsage = (\n        (utils.getParentES6Component() || utils.getParentES5Component()) &&\n        node.object.type === 'ThisExpression' && node.property.name === 'props'\n      );\n      var isStatelessFunctionUsage = node.object.name === 'props';\n      return isClassUsage || isStatelessFunctionUsage;\n    }\n\n    /**\n     * Checks if we are declaring a `props` class property with a flow type annotation.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node is a type annotated props declaration, false if not.\n     */\n    function isAnnotatedClassPropsDeclaration(node) {\n      if (node && node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        if (\n          node.typeAnnotation && (\n            tokens[0].value === 'props' ||\n            (tokens[1] && tokens[1].value === 'props')\n          )\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Checks if we are declaring a prop\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a prop, false if not.\n     */\n    function isPropTypesDeclaration(node) {\n\n      // Special case for class properties\n      // (babel-eslint does not expose property name so we have to rely on tokens)\n      if (node && node.type === 'ClassProperty') {\n        var tokens = context.getFirstTokens(node, 2);\n        if (\n          tokens[0].value === 'propTypes' ||\n          (tokens[1] && tokens[1].value === 'propTypes')\n        ) {\n          return true;\n        }\n        return false;\n      }\n\n      return Boolean(\n        node &&\n        node.name === 'propTypes'\n      );\n\n    }\n\n    /**\n     * Checks if prop should be validated by plugin-react-proptypes\n     * @param {String} validator Name of validator to check.\n     * @returns {Boolean} True if validator should be checked by custom validator.\n     */\n    function hasCustomValidator(validator) {\n      return customValidators.indexOf(validator) !== -1;\n    }\n\n    /**\n     * Checks if the component must be validated\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component must be validated, false if not.\n     */\n    function mustBeValidated(component) {\n      return Boolean(\n        component &&\n        component.usedPropTypes &&\n        !component.ignorePropsValidation\n      );\n    }\n\n    /**\n     * Returns true if the given node is a React Component lifecycle method\n     * @param {ASTNode} node The AST node being checked.\n     * @return {Boolean} True if the node is a lifecycle method\n     */\n    function isNodeALifeCycleMethod(node) {\n      var nodeKeyName = (node.key || {}).name;\n      return (\n        node.kind === 'constructor' ||\n        nodeKeyName === 'componentWillReceiveProps' ||\n        nodeKeyName === 'shouldComponentUpdate' ||\n        nodeKeyName === 'componentWillUpdate' ||\n        nodeKeyName === 'componentDidUpdate'\n      );\n    }\n\n    /**\n     * Returns true if the given node is inside a React Component lifecycle\n     * method.\n     * @param {ASTNode} node The AST node being checked.\n     * @return {Boolean} True if the node is inside a lifecycle method\n     */\n    function isInLifeCycleMethod(node) {\n      if (node.type === 'MethodDefinition' && isNodeALifeCycleMethod(node)) {\n        return true;\n      }\n\n      if (node.parent) {\n        return isInLifeCycleMethod(node.parent);\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks if a prop init name matches common naming patterns\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the prop name matches\n     */\n    function isPropAttributeName (node) {\n      return (\n        node.init.name === 'props' ||\n        node.init.name === 'nextProps' ||\n        node.init.name === 'prevProps'\n      );\n    }\n\n    /**\n     * Checks if a prop is used\n     * @param {ASTNode} node The AST node being checked.\n     * @param {Object} prop Declared prop object\n     * @returns {Boolean} True if the prop is used, false if not.\n     */\n    function isPropUsed(node, prop) {\n      for (var i = 0, l = node.usedPropTypes.length; i < l; i++) {\n        var usedProp = node.usedPropTypes[i];\n        if (\n          prop.type === 'shape' ||\n          prop.name === '__ANY_KEY__' ||\n          usedProp.name === prop.name\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks if the prop has spread operator.\n     * @param {ASTNode} node The AST node being marked.\n     * @returns {Boolean} True if the prop has spread operator, false if not.\n     */\n    function hasSpreadOperator(node) {\n      var tokens = sourceCode.getTokens(node);\n      return tokens.length && tokens[0].value === '...';\n    }\n\n    /**\n     * Retrieve the name of a key node\n     * @param {ASTNode} node The AST node with the key.\n     * @return {string} the name of the key\n     */\n    function getKeyValue(node) {\n      if (node.type === 'ObjectTypeProperty') {\n        var tokens = context.getFirstTokens(node, 1);\n        return tokens[0].value;\n      }\n      var key = node.key || node.argument;\n      return key.type === 'Identifier' ? key.name : key.value;\n    }\n\n    /**\n     * Iterates through a properties node, like a customized forEach.\n     * @param {Object[]} properties Array of properties to iterate.\n     * @param {Function} fn Function to call on each property, receives property key\n        and property value. (key, value) => void\n     */\n    function iterateProperties(properties, fn) {\n      if (properties.length && typeof fn === 'function') {\n        for (var i = 0, j = properties.length; i < j; i++) {\n          var node = properties[i];\n          var key = getKeyValue(node);\n\n          var value = node.value;\n          fn(key, value);\n        }\n      }\n    }\n\n    /**\n     * Creates the representation of the React propTypes for the component.\n     * The representation is used to verify nested used properties.\n     * @param {ASTNode} value Node of the React.PropTypes for the desired property\n     * @param {String} parentName Name of the parent prop node.\n     * @return {Object|Boolean} The representation of the declaration, true means\n     *    the property is declared without the need for further analysis.\n     */\n    function buildReactDeclarationTypes(value, parentName) {\n      if (\n        value &&\n        value.callee &&\n        value.callee.object &&\n        hasCustomValidator(value.callee.object.name)\n      ) {\n        return true;\n      }\n\n      if (\n        value &&\n        value.type === 'MemberExpression' &&\n        value.property &&\n        value.property.name &&\n        value.property.name === 'isRequired'\n      ) {\n        value = value.object;\n      }\n\n      // Verify React.PropTypes that are functions\n      if (\n        value &&\n        value.type === 'CallExpression' &&\n        value.callee &&\n        value.callee.property &&\n        value.callee.property.name &&\n        value.arguments &&\n        value.arguments.length > 0\n      ) {\n        var callName = value.callee.property.name;\n        var argument = value.arguments[0];\n        switch (callName) {\n          case 'shape':\n            if (skipShapeProps) {\n              return true;\n            }\n\n            if (argument.type !== 'ObjectExpression') {\n              // Invalid proptype or cannot analyse statically\n              return true;\n            }\n            var shapeTypeDefinition = {\n              type: 'shape',\n              children: []\n            };\n            iterateProperties(argument.properties, function(childKey, childValue) {\n              var fullName = [parentName, childKey].join('.');\n              var types = buildReactDeclarationTypes(childValue, fullName);\n              if (types === true) {\n                types = {};\n              }\n              types.fullName = fullName;\n              types.name = childKey;\n              types.node = childValue;\n              shapeTypeDefinition.children.push(types);\n            });\n            return shapeTypeDefinition;\n          case 'arrayOf':\n          case 'objectOf':\n            var fullName = [parentName, '*'].join('.');\n            var child = buildReactDeclarationTypes(argument, fullName);\n            if (child === true) {\n              child = {};\n            }\n            child.fullName = fullName;\n            child.name = '__ANY_KEY__';\n            child.node = argument;\n            return {\n              type: 'object',\n              children: [child]\n            };\n          case 'oneOfType':\n            if (\n              !argument.elements ||\n              !argument.elements.length\n            ) {\n              // Invalid proptype or cannot analyse statically\n              return true;\n            }\n            var unionTypeDefinition = {\n              type: 'union',\n              children: []\n            };\n            for (var i = 0, j = argument.elements.length; i < j; i++) {\n              var type = buildReactDeclarationTypes(argument.elements[i], parentName);\n              // keep only complex type\n              if (type !== true) {\n                if (type.children === true) {\n                  // every child is accepted for one type, abort type analysis\n                  unionTypeDefinition.children = true;\n                  return unionTypeDefinition;\n                }\n              }\n\n              unionTypeDefinition.children.push(type);\n            }\n            if (unionTypeDefinition.length === 0) {\n              // no complex type found, simply accept everything\n              return true;\n            }\n            return unionTypeDefinition;\n          case 'instanceOf':\n            return {\n              type: 'instance',\n              // Accept all children because we can't know what type they are\n              children: true\n            };\n          case 'oneOf':\n          default:\n            return true;\n        }\n      }\n      // Unknown property or accepts everything (any, object, ...)\n      return true;\n    }\n\n    /**\n     * Creates the representation of the React props type annotation for the component.\n     * The representation is used to verify nested used properties.\n     * @param {ASTNode} annotation Type annotation for the props class property.\n     * @param {String} parentName Name of the parent prop node.\n     * @return {Object|Boolean} The representation of the declaration, true means\n     *    the property is declared without the need for further analysis.\n     */\n    function buildTypeAnnotationDeclarationTypes(annotation, parentName) {\n      switch (annotation.type) {\n        case 'GenericTypeAnnotation':\n          if (typeScope(annotation.id.name)) {\n            return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name), parentName);\n          }\n          return true;\n        case 'ObjectTypeAnnotation':\n          var shapeTypeDefinition = {\n            type: 'shape',\n            children: []\n          };\n          iterateProperties(annotation.properties, function(childKey, childValue) {\n            var fullName = [parentName, childKey].join('.');\n            var types = buildTypeAnnotationDeclarationTypes(childValue, fullName);\n            if (types === true) {\n              types = {};\n            }\n            types.fullName = fullName;\n            types.name = childKey;\n            types.node = childValue;\n            shapeTypeDefinition.children.push(types);\n          });\n          return shapeTypeDefinition;\n        case 'UnionTypeAnnotation':\n          var unionTypeDefinition = {\n            type: 'union',\n            children: []\n          };\n          for (var i = 0, j = annotation.types.length; i < j; i++) {\n            var type = buildTypeAnnotationDeclarationTypes(annotation.types[i], parentName);\n            // keep only complex type\n            if (type !== true) {\n              if (type.children === true) {\n                // every child is accepted for one type, abort type analysis\n                unionTypeDefinition.children = true;\n                return unionTypeDefinition;\n              }\n            }\n\n            unionTypeDefinition.children.push(type);\n          }\n          if (unionTypeDefinition.children.length === 0) {\n            // no complex type found, simply accept everything\n            return true;\n          }\n          return unionTypeDefinition;\n        case 'ArrayTypeAnnotation':\n          var fullName = [parentName, '*'].join('.');\n          var child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName);\n          if (child === true) {\n            child = {};\n          }\n          child.fullName = fullName;\n          child.name = '__ANY_KEY__';\n          child.node = annotation;\n          return {\n            type: 'object',\n            children: [child]\n          };\n        default:\n          // Unknown or accepts everything.\n          return true;\n      }\n    }\n\n    /**\n     * Check if we are in a class constructor\n     * @return {boolean} true if we are in a class constructor, false if not\n     */\n    function inConstructor() {\n      var scope = context.getScope();\n      while (scope) {\n        if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n          return true;\n        }\n        scope = scope.upper;\n      }\n      return false;\n    }\n\n    /**\n     * Retrieve the name of a property node\n     * @param {ASTNode} node The AST node with the property.\n     * @return {string} the name of the property or undefined if not found\n     */\n    function getPropertyName(node) {\n      var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));\n      var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();\n      var isNotInConstructor = !inConstructor(node);\n      if (isDirectProp && isInClassComponent && isNotInConstructor) {\n        return void 0;\n      }\n      if (!isDirectProp) {\n        node = node.parent;\n      }\n      var property = node.property;\n      if (property) {\n        switch (property.type) {\n          case 'Identifier':\n            if (node.computed) {\n              return '__COMPUTED_PROP__';\n            }\n            return property.name;\n          case 'MemberExpression':\n            return void 0;\n          case 'Literal':\n            // Accept computed properties that are literal strings\n            if (typeof property.value === 'string') {\n              return property.value;\n            }\n            // falls through\n          default:\n            if (node.computed) {\n              return '__COMPUTED_PROP__';\n            }\n            break;\n        }\n      }\n      return void 0;\n    }\n\n    /**\n     * Mark a prop type as used\n     * @param {ASTNode} node The AST node being marked.\n     */\n    function markPropTypesAsUsed(node, parentNames) {\n      parentNames = parentNames || [];\n      var type;\n      var name;\n      var allNames;\n      var properties;\n      switch (node.type) {\n        case 'MemberExpression':\n          name = getPropertyName(node);\n          if (name) {\n            allNames = parentNames.concat(name);\n            if (node.parent.type === 'MemberExpression') {\n              markPropTypesAsUsed(node.parent, allNames);\n            }\n            // Do not mark computed props as used.\n            type = name !== '__COMPUTED_PROP__' ? 'direct' : null;\n          } else if (\n            node.parent.id &&\n            node.parent.id.properties &&\n            node.parent.id.properties.length &&\n            getKeyValue(node.parent.id.properties[0])\n          ) {\n            type = 'destructuring';\n            properties = node.parent.id.properties;\n          }\n          break;\n        case 'ArrowFunctionExpression':\n        case 'FunctionDeclaration':\n        case 'FunctionExpression':\n          type = 'destructuring';\n          properties = node.params[0].properties;\n          break;\n        case 'VariableDeclarator':\n          for (var i = 0, j = node.id.properties.length; i < j; i++) {\n            // let {props: {firstname}} = this\n            var thisDestructuring = (\n              node.id.properties[i].key && (\n                (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') &&\n                node.id.properties[i].value.type === 'ObjectPattern'\n              )\n            );\n            // let {firstname} = props\n            var genericDestructuring = isPropAttributeName(node) && (\n                utils.getParentStatelessComponent() ||\n                isInLifeCycleMethod(node)\n            );\n\n            if (thisDestructuring) {\n              properties = node.id.properties[i].value.properties;\n            } else if (genericDestructuring) {\n              properties = node.id.properties;\n            } else {\n              continue;\n            }\n            type = 'destructuring';\n            break;\n          }\n          break;\n        default:\n          throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');\n      }\n\n      var component = components.get(utils.getParentComponent());\n      var usedPropTypes = component && component.usedPropTypes || [];\n      var ignorePropsValidation = component && component.ignorePropsValidation || false;\n\n      switch (type) {\n        case 'direct':\n          // Ignore Object methods\n          if (Object.prototype[name]) {\n            break;\n          }\n\n          usedPropTypes.push({\n            name: name,\n            allNames: allNames\n          });\n          break;\n        case 'destructuring':\n          for (var k = 0, l = (properties || []).length; k < l; k++) {\n            if (hasSpreadOperator(properties[k]) || properties[k].computed) {\n              ignorePropsValidation = true;\n              break;\n            }\n            var propName = getKeyValue(properties[k]);\n\n            var currentNode = node;\n            allNames = [];\n            while (currentNode.property && currentNode.property.name !== 'props') {\n              allNames.unshift(currentNode.property.name);\n              currentNode = currentNode.object;\n            }\n            allNames.push(propName);\n\n            if (propName) {\n              usedPropTypes.push({\n                allNames: allNames,\n                name: propName\n              });\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      components.set(node, {\n        usedPropTypes: usedPropTypes,\n        ignorePropsValidation: ignorePropsValidation\n      });\n    }\n\n    /**\n     * Mark a prop type as declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {propTypes} node The AST node containing the proptypes\n     */\n    function markPropTypesAsDeclared(node, propTypes) {\n      var component = components.get(node);\n      var declaredPropTypes = component && component.declaredPropTypes || [];\n      var ignorePropsValidation = component && component.ignorePropsValidation || false;\n\n      switch (propTypes && propTypes.type) {\n        case 'ObjectTypeAnnotation':\n          iterateProperties(propTypes.properties, function(key, value) {\n            var types = buildTypeAnnotationDeclarationTypes(value, key);\n            if (types === true) {\n              types = {};\n            }\n            types.fullName = key;\n            types.name = key;\n            types.node = value;\n            declaredPropTypes.push(types);\n          });\n          break;\n        case 'ObjectExpression':\n          iterateProperties(propTypes.properties, function(key, value) {\n            if (!value) {\n              ignorePropsValidation = true;\n              return;\n            }\n            var types = buildReactDeclarationTypes(value, key);\n            if (types === true) {\n              types = {};\n            }\n            types.fullName = key;\n            types.name = key;\n            types.node = value;\n            declaredPropTypes.push(types);\n          });\n          break;\n        case 'MemberExpression':\n          break;\n        case 'Identifier':\n          var variablesInScope = variable.variablesInScope(context);\n          for (var i = 0, j = variablesInScope.length; i < j; i++) {\n            if (variablesInScope[i].name !== propTypes.name) {\n              continue;\n            }\n            var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];\n            markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);\n            return;\n          }\n          ignorePropsValidation = true;\n          break;\n        case null:\n          break;\n        default:\n          ignorePropsValidation = true;\n          break;\n      }\n\n      components.set(node, {\n        declaredPropTypes: declaredPropTypes,\n        ignorePropsValidation: ignorePropsValidation\n      });\n    }\n\n    /**\n     * Used to recursively loop through each declared prop type\n     * @param {Object} component The component to process\n     * @param {Array} props List of props to validate\n     */\n    function reportUnusedPropType (component, props) {\n      // Skip props that check instances\n      if (props === true) {\n        return;\n      }\n\n      (props || []).forEach(function (prop) {\n        // Skip props that check instances\n        if (prop === true) {\n          return;\n        }\n\n        if (prop.node && !isPropUsed(component, prop)) {\n          context.report(\n            prop.node,\n              UNUSED_MESSAGE, {\n                name: prop.fullName\n              }\n          );\n        }\n\n        if (prop.children) {\n          reportUnusedPropType(component, prop.children);\n        }\n      });\n    }\n\n    /**\n     * Reports unused proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportUnusedPropTypes(component) {\n      reportUnusedPropType(component, component.declaredPropTypes);\n    }\n\n    /**\n     * Resolve the type annotation for a given node.\n     * Flow annotations are sometimes wrapped in outer `TypeAnnotation`\n     * and `NullableTypeAnnotation` nodes which obscure the annotation we're\n     * interested in.\n     * This method also resolves type aliases where possible.\n     *\n     * @param {ASTNode} node The annotation or a node containing the type annotation.\n     * @returns {ASTNode} The resolved type annotation for the node.\n     */\n    function resolveTypeAnnotation(node) {\n      var annotation = node.typeAnnotation || node;\n      while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n        annotation = annotation.typeAnnotation;\n      }\n      if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {\n        return typeScope(annotation.id.name);\n      }\n      return annotation;\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function markDestructuredFunctionArgumentsAsUsed(node) {\n      var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';\n      if (destructuring && components.get(node)) {\n        markPropTypesAsUsed(node);\n      }\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function markAnnotatedFunctionArgumentsAsDeclared(node) {\n      if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {\n        return;\n      }\n      markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));\n    }\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function handleStatelessComponent(node) {\n      markDestructuredFunctionArgumentsAsUsed(node);\n      markAnnotatedFunctionArgumentsAsDeclared(node);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      ClassProperty: function(node) {\n        if (isAnnotatedClassPropsDeclaration(node)) {\n          markPropTypesAsDeclared(node, resolveTypeAnnotation(node));\n        } else if (isPropTypesDeclaration(node)) {\n          markPropTypesAsDeclared(node, node.value);\n        }\n      },\n\n      VariableDeclarator: function(node) {\n        var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';\n        // let {props: {firstname}} = this\n        var thisDestructuring = destructuring && node.init.type === 'ThisExpression';\n        // let {firstname} = props\n        var statelessDestructuring = destructuring && isPropAttributeName(node) && (\n            utils.getParentStatelessComponent() ||\n            isInLifeCycleMethod(node)\n        );\n\n        if (!thisDestructuring && !statelessDestructuring) {\n          return;\n        }\n        markPropTypesAsUsed(node);\n      },\n\n      FunctionDeclaration: handleStatelessComponent,\n\n      ArrowFunctionExpression: handleStatelessComponent,\n\n      FunctionExpression: handleStatelessComponent,\n\n      MemberExpression: function(node) {\n        var type;\n        if (isPropTypesUsage(node)) {\n          type = 'usage';\n        } else if (isPropTypesDeclaration(node.property)) {\n          type = 'declaration';\n        }\n\n        switch (type) {\n          case 'usage':\n            markPropTypesAsUsed(node);\n            break;\n          case 'declaration':\n            var component = utils.getRelatedComponent(node);\n            if (!component) {\n              return;\n            }\n            markPropTypesAsDeclared(component.node, node.parent.right || node.parent);\n            break;\n          default:\n            break;\n        }\n      },\n\n      MethodDefinition: function(node) {\n        if (!isPropTypesDeclaration(node.key)) {\n          return;\n        }\n\n        var i = node.value.body.body.length - 1;\n        for (; i >= 0; i--) {\n          if (node.value.body.body[i].type === 'ReturnStatement') {\n            break;\n          }\n        }\n\n        if (i >= 0) {\n          markPropTypesAsDeclared(node, node.value.body.body[i].argument);\n        }\n      },\n\n      ObjectPattern: function(node) {\n        // If the object pattern is a destructured props object in a lifecycle\n        // method -- mark it for used props.\n        if (isNodeALifeCycleMethod(node.parent.parent)) {\n          node.properties.forEach(function(property, i) {\n            if (i === 0) {\n              markPropTypesAsUsed(node.parent);\n            }\n          });\n        }\n      },\n\n      ObjectExpression: function(node) {\n        // Search for the proptypes declaration\n        node.properties.forEach(function(property) {\n          if (!isPropTypesDeclaration(property.key)) {\n            return;\n          }\n          markPropTypesAsDeclared(node, property.value);\n        });\n      },\n\n      TypeAlias: function(node) {\n        typeScope(node.id.name, node.right);\n      },\n\n      Program: function() {\n        stack = [{}];\n      },\n\n      BlockStatement: function () {\n        stack.push(Object.create(typeScope()));\n      },\n\n      'BlockStatement:exit': function () {\n        stack.pop();\n      },\n\n      'Program:exit': function() {\n        stack = null;\n        var list = components.list();\n        // Report undeclared proptypes for all classes\n        for (var component in list) {\n          if (!has(list, component) || !mustBeValidated(list[component])) {\n            continue;\n          }\n          reportUnusedPropTypes(list[component]);\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-children-prop.js":"/**\n * @fileoverview Prevent passing of children as props\n * @author Benjamin Stepp\n */\n'use strict';\n\nvar find = require('array.prototype.find');\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n/**\n * Checks if the node is a createElement call with a props literal.\n * @param {ASTNode} node - The AST node being checked.\n * @returns {Boolean} - True if node is a createElement call with a props\n * object literal, False if not.\n*/\nfunction isCreateElementWithProps(node) {\n  return node.callee\n    && node.callee.type === 'MemberExpression'\n    && node.callee.property.name === 'createElement'\n    && node.arguments.length > 1\n    && node.arguments[1].type === 'ObjectExpression';\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent passing of children as props.',\n      category: 'Best Practices',\n      recommended: false\n    },\n    schema: []\n  },\n  create: function(context) {\n    return {\n      JSXAttribute: function(node) {\n        if (node.name.name !== 'children') {\n          return;\n        }\n\n        context.report({\n          node: node,\n          message: 'Do not pass children as props. Instead, nest children between the opening and closing tags.'\n        });\n      },\n      CallExpression: function(node) {\n        if (!isCreateElementWithProps(node)) {\n          return;\n        }\n\n        var props = node.arguments[1].properties;\n        var childrenProp = find(props, function(prop) {\n          return prop.key && prop.key.name === 'children';\n        });\n\n        if (childrenProp) {\n          context.report({\n            node: node,\n            message: 'Do not pass children as props. Instead, pass them as additional arguments to React.createElement.'\n          });\n        }\n      }\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/void-dom-elements-no-children.js":"/**\n * @fileoverview Prevent void elements (e.g. <img />, <br />) from receiving\n *   children\n * @author Joe Lencioni\n */\n'use strict';\n\nvar find = require('array.prototype.find');\nvar has = require('has');\n\nvar Components = require('../util/Components');\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n// Using an object here to avoid array scan. We should switch to Set once\n// support is good enough.\nvar VOID_DOM_ELEMENTS = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  menuitem: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nfunction isVoidDOMElement(elementName) {\n  return has(VOID_DOM_ELEMENTS, elementName);\n}\n\nfunction errorMessage(elementName) {\n  return 'Void DOM element <' + elementName + ' /> cannot receive children.';\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prevent passing of children to void DOM elements (e.g. <br />).',\n      category: 'Best Practices',\n      recommended: false\n    },\n    schema: []\n  },\n\n  create: Components.detect(function(context, components, utils) {\n    return {\n      JSXElement: function(node) {\n        var elementName = node.openingElement.name.name;\n\n        if (!isVoidDOMElement(elementName)) {\n          // e.g. <div />\n          return;\n        }\n\n        if (node.children.length > 0) {\n          // e.g. <br>Foo</br>\n          context.report({\n            node: node,\n            message: errorMessage(elementName)\n          });\n        }\n\n        var attributes = node.openingElement.attributes;\n\n        var hasChildrenAttributeOrDanger = !!find(attributes, function(attribute) {\n          if (!attribute.name) {\n            return false;\n          }\n\n          return attribute.name.name === 'children' || attribute.name.name === 'dangerouslySetInnerHTML';\n        });\n\n        if (hasChildrenAttributeOrDanger) {\n          // e.g. <br children=\"Foo\" />\n          context.report({\n            node: node,\n            message: errorMessage(elementName)\n          });\n        }\n      },\n\n      CallExpression: function(node) {\n        if (node.callee.type !== 'MemberExpression' && node.callee.type !== 'Identifier') {\n          return;\n        }\n\n        if (!utils.hasDestructuredReactCreateElement() && !utils.isReactCreateElement(node)) {\n          return;\n        }\n\n        var args = node.arguments;\n        var elementName = args[0].value;\n\n        if (!isVoidDOMElement(elementName)) {\n          // e.g. React.createElement('div');\n          return;\n        }\n\n        if (args.length < 2) {\n          return;\n        }\n\n        var firstChild = args[2];\n        if (firstChild) {\n          // e.g. React.createElement('br', undefined, 'Foo')\n          context.report({\n            node: node,\n            message: errorMessage(elementName)\n          });\n        }\n\n        var props = args[1].properties;\n\n        var hasChildrenPropOrDanger = !!find(props, function(prop) {\n          if (!prop.key) {\n            return false;\n          }\n\n          return prop.key.name === 'children' || prop.key.name === 'dangerouslySetInnerHTML';\n        });\n\n        if (hasChildrenPropOrDanger) {\n          // e.g. React.createElement('br', { children: 'Foo' })\n          context.report({\n            node: node,\n            message: errorMessage(elementName)\n          });\n        }\n      }\n    };\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/no-comment-textnodes.js":"/**\n * @fileoverview Comments inside children section of tag should be placed inside braces.\n * @author Ben Vinegar\n * @deprecated\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nvar util = require('util');\nvar jsxNoCommentTextnodes = require('./jsx-no-comment-textnodes');\nvar isWarnedForDeprecation = false;\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    docs: {\n      description: 'Comments inside children section of tag should be placed inside braces',\n      category: 'Possible Errors',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {},\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n    return util._extend(jsxNoCommentTextnodes.create(context), {\n      Program: function() {\n        if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n          return;\n        }\n\n        /* eslint-disable no-console */\n        console.log('The react/no-comment-textnodes rule is deprecated. Please ' +\n                    'use the react/jsx-no-comment-textnodes rule instead.');\n        /* eslint-enable no-console */\n        isWarnedForDeprecation = true;\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/require-extension.js":"/**\n * @fileoverview Restrict file extensions that may be required\n * @author Scott Andrews\n * @deprecated\n */\n'use strict';\n\nvar path = require('path');\nvar isWarnedForDeprecation = false;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nvar DEFAULTS = {\n  extensions: ['.jsx']\n};\n\nvar PKG_REGEX = /^[^\\.]((?!\\/).)*$/;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    docs: {\n      description: 'Restrict file extensions that may be required',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n\n    schema: [{\n      type: 'object',\n      properties: {\n        extensions: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n\n    function isPackage(id) {\n      return PKG_REGEX.test(id);\n    }\n\n    function isRequire(expression) {\n      return expression.callee.name === 'require';\n    }\n\n    function getId(expression) {\n      return expression.arguments[0] && expression.arguments[0].value;\n    }\n\n    function getExtension(id) {\n      return path.extname(id || '');\n    }\n\n    function getExtensionsConfig() {\n      return context.options[0] && context.options[0].extensions || DEFAULTS.extensions;\n    }\n\n    var forbiddenExtensions = getExtensionsConfig().reduce(function (extensions, extension) {\n      extensions[extension] = true;\n      return extensions;\n    }, Object.create(null));\n\n    function isForbiddenExtension(ext) {\n      return ext in forbiddenExtensions;\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      CallExpression: function(node) {\n        if (isRequire(node)) {\n          var id = getId(node);\n          var ext = getExtension(id);\n          if (!isPackage(id) && isForbiddenExtension(ext)) {\n            context.report({\n              node: node,\n              message: 'Unable to require module with extension \\'' + ext + '\\''\n            });\n          }\n        }\n      },\n\n      Program: function() {\n        if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n          return;\n        }\n\n        /* eslint-disable no-console */\n        console.log('The react/require-extension rule is deprecated. Please ' +\n                    'use the import/extensions rule from eslint-plugin-import instead.');\n        /* eslint-enable no-console */\n        isWarnedForDeprecation = true;\n      }\n\n    };\n\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/wrap-multilines.js":"/**\n * @fileoverview Prevent missing parentheses around multilines JSX\n * @author Yannick Croissant\n * @deprecated\n */\n'use strict';\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nvar util = require('util');\nvar jsxWrapMultilines = require('./jsx-wrap-multilines');\nvar isWarnedForDeprecation = false;\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    docs: {\n      description: 'Prevent missing parentheses around multilines JSX',\n      category: 'Stylistic Issues',\n      recommended: false\n    },\n    fixable: 'code',\n\n    schema: [{\n      type: 'object',\n      properties: {\n        declaration: {\n          type: 'boolean'\n        },\n        assignment: {\n          type: 'boolean'\n        },\n        return: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create: function(context) {\n    return util._extend(jsxWrapMultilines.create(context), {\n      Program: function() {\n        if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n          return;\n        }\n\n        /* eslint-disable no-console */\n        console.log('The react/wrap-multilines rule is deprecated. Please ' +\n                    'use the react/jsx-wrap-multilines rule instead.');\n        /* eslint-enable no-console */\n        isWarnedForDeprecation = true;\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-react/node_modules/eslint-plugin-react/lib/rules/jsx-tag-spacing.js":"/**\n * @fileoverview Validates whitespace in and around the JSX opening and closing brackets\n * @author Diogo Franco (Kovensky)\n */\n'use strict';\n\nvar has = require('has');\nvar getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');\n\n// ------------------------------------------------------------------------------\n// Validators\n// ------------------------------------------------------------------------------\n\nfunction validateClosingSlash(context, node, option) {\n  var sourceCode = context.getSourceCode();\n\n  var SELF_CLOSING_NEVER_MESSAGE = 'Whitespace is forbidden between `/` and `>`; write `/>`';\n  var SELF_CLOSING_ALWAYS_MESSAGE = 'Whitespace is required between `/` and `>`; write `/ >`';\n  var NEVER_MESSAGE = 'Whitespace is forbidden between `<` and `/`; write `</`';\n  var ALWAYS_MESSAGE = 'Whitespace is required between `<` and `/`; write `< /`';\n\n  var adjacent;\n\n  if (node.selfClosing) {\n    var lastTokens = sourceCode.getLastTokens(node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        context.report({\n          node: node,\n          loc: {\n            start: lastTokens[0].loc.start,\n            end: lastTokens[1].loc.end\n          },\n          message: SELF_CLOSING_NEVER_MESSAGE,\n          fix: function(fixer) {\n            return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);\n          }\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      context.report({\n        node: node,\n        loc: {\n          start: lastTokens[0].loc.start,\n          end: lastTokens[1].loc.end\n        },\n        message: SELF_CLOSING_ALWAYS_MESSAGE,\n        fix: function(fixer) {\n          return fixer.insertTextBefore(lastTokens[1], ' ');\n        }\n      });\n    }\n  } else {\n    var firstTokens = sourceCode.getFirstTokens(node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        context.report({\n          node: node,\n          loc: {\n            start: firstTokens[0].loc.start,\n            end: firstTokens[1].loc.end\n          },\n          message: NEVER_MESSAGE,\n          fix: function(fixer) {\n            return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);\n          }\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      context.report({\n        node: node,\n        loc: {\n          start: firstTokens[0].loc.start,\n          end: firstTokens[1].loc.end\n        },\n        message: ALWAYS_MESSAGE,\n        fix: function(fixer) {\n          return fixer.insertTextBefore(firstTokens[1], ' ');\n        }\n      });\n    }\n  }\n}\n\nfunction validateBeforeSelfClosing(context, node, option) {\n  var sourceCode = context.getSourceCode();\n\n  var NEVER_MESSAGE = 'A space is forbidden before closing bracket';\n  var ALWAYS_MESSAGE = 'A space is required before closing bracket';\n\n  var leftToken = getTokenBeforeClosingBracket(node);\n  var closingSlash = sourceCode.getTokenAfter(leftToken);\n\n  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {\n    return;\n  }\n\n  if (option === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {\n    context.report({\n      node: node,\n      loc: closingSlash.loc.start,\n      message: ALWAYS_MESSAGE,\n      fix: function(fixer) {\n        return fixer.insertTextBefore(closingSlash, ' ');\n      }\n    });\n  } else if (option === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {\n    context.report({\n      node: node,\n      loc: closingSlash.loc.start,\n      message: NEVER_MESSAGE,\n      fix: function(fixer) {\n        var previousToken = sourceCode.getTokenBefore(closingSlash);\n        return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);\n      }\n    });\n  }\n}\n\nfunction validateAfterOpening(context, node, option) {\n  var sourceCode = context.getSourceCode();\n\n  var NEVER_MESSAGE = 'A space is forbidden after opening bracket';\n  var ALWAYS_MESSAGE = 'A space is required after opening bracket';\n\n  var openingToken = sourceCode.getTokenBefore(node.name);\n\n  if (option === 'allow-multiline') {\n    if (openingToken.loc.start.line !== node.name.loc.start.line) {\n      return;\n    }\n  }\n\n  var adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);\n\n  if (option === 'never' || option === 'allow-multiline') {\n    if (!adjacent) {\n      context.report({\n        node: node,\n        loc: {\n          start: openingToken.loc.start,\n          end: node.name.loc.start\n        },\n        message: NEVER_MESSAGE,\n        fix: function(fixer) {\n          return fixer.removeRange([openingToken.range[1], node.name.range[0]]);\n        }\n      });\n    }\n  } else if (option === 'always' && adjacent) {\n    context.report({\n      node: node,\n      loc: {\n        start: openingToken.loc.start,\n        end: node.name.loc.start\n      },\n      message: ALWAYS_MESSAGE,\n      fix: function(fixer) {\n        return fixer.insertTextBefore(node.name, ' ');\n      }\n    });\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nmodule.exports = {\n  meta: {\n    docs: {},\n    fixable: 'whitespace',\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          closingSlash: {\n            enum: ['always', 'never', 'allow']\n          },\n          beforeSelfClosing: {\n            enum: ['always', 'never', 'allow']\n          },\n          afterOpening: {\n            enum: ['always', 'allow-multiline', 'never', 'allow']\n          }\n        },\n        default: {\n          closingSlash: 'never',\n          beforeSelfClosing: 'always',\n          afterOpening: 'never'\n        },\n        additionalProperties: false\n      }\n    ]\n  },\n  create: function (context) {\n    var options = {\n      closingSlash: 'never',\n      beforeSelfClosing: 'always',\n      afterOpening: 'never'\n    };\n    for (var key in options) {\n      if (has(options, key) && has(context.options[0] || {}, key)) {\n        options[key] = context.options[0][key];\n      }\n    }\n\n    return {\n      JSXOpeningElement: function (node) {\n        if (options.closingSlash !== 'allow' && node.selfClosing) {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {\n          validateBeforeSelfClosing(context, node, options.beforeSelfClosing);\n        }\n      },\n      JSXClosingElement: function (node) {\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.closingSlash !== 'allow') {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n      }\n    };\n  }\n};\n"}